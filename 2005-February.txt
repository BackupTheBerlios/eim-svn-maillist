From jol at sheep.berlios.de  Mon Feb  7 20:32:31 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Mon, 7 Feb 2005 20:32:31 +0100
Subject: [Eim-svn] r4 - / src/egxp
Message-ID: <200502071932.j17JWVAx009516@sheep.berlios.de>

Author: jol
Date: 2005-02-07 20:32:30 +0100 (Mon, 07 Feb 2005)
New Revision: 4

Modified:
   ChangeLog
   src/egxp/egxp.h
   src/egxp/egxp_condition.c
   src/egxp/egxp_condition.h
   src/egxp/egxp_conditional_node.c
   src/egxp/egxp_conditional_node.h
   src/egxp/egxp_node.c
   src/egxp/egxp_node.h
   src/egxp/egxp_opcode.c
   src/egxp/egxp_opcode.h
   src/egxp/test.c
Log:
- do not return pointer with egxp_opcode_get_id
- add functions to egxp_conditional_node with some helper function
- update the test example



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-06 22:18:47 UTC (rev 3)
+++ ChangeLog	2005-02-07 19:32:30 UTC (rev 4)
@@ -1,3 +1,8 @@
+2005-02-07(jol):
+	- do not return pointer with egxp_opcode_get_id
+	- add functions to egxp_conditional_node with some helper function
+	- update the test example
+	
 2005-02-06(jol):
 	- fix a memleak from egxp_free
 	- add Egxp_ConditionalNode

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp.h	2005-02-07 19:32:30 UTC (rev 4)
@@ -7,8 +7,8 @@
 #include "egxp_opcode.h"
 #include "egxp_condition.h"
 #include "egxp_message.h"
+#include "egxp_conditional_node.h"
 
-
 typedef struct _Egxp Egxp;
 #define EGXP(o) ((Egxp*)o)
 struct _Egxp {

Modified: src/egxp/egxp_condition.c
===================================================================
--- src/egxp/egxp_condition.c	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_condition.c	2005-02-07 19:32:30 UTC (rev 4)
@@ -3,7 +3,7 @@
 
 #include "egxp_condition.h"
 
-Egxp_Condition * egxp_condition_new (const unsigned int key, const unsigned int value) {
+Egxp_Condition * egxp_condition_new (const int key, const int value) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_condition_new\n");
 #endif

Modified: src/egxp/egxp_condition.h
===================================================================
--- src/egxp/egxp_condition.h	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_condition.h	2005-02-07 19:32:30 UTC (rev 4)
@@ -8,7 +8,7 @@
  * @param key: the id of the key
  * @param value: the id of the value
  */
-Egxp_Condition * egxp_condition_new (const unsigned int key, const unsigned int value); 
+Egxp_Condition * egxp_condition_new (const int key, const int value); 
 
 /**
  * Free the memory of the condition

Modified: src/egxp/egxp_conditional_node.c
===================================================================
--- src/egxp/egxp_conditional_node.c	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_conditional_node.c	2005-02-07 19:32:30 UTC (rev 4)
@@ -1,6 +1,9 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <Ecore_Data.h>
+
+#include "egxp_child_node.h"
+#include "egxp_node.h"
 #include "egxp_conditional_node.h"
 
 Egxp_ConditionalNode * egxp_conditional_node_new (Egxp_Node * parent) {
@@ -9,21 +12,87 @@
 #endif
   assert (parent);
   
+  /* create and initialize the structure */
   Egxp_ConditionalNode * tmp = EGXP_CONDITIONALNODE(malloc (sizeof(Egxp_ConditionalNode)));
   tmp->parent = parent;
   tmp->conditions = NULL;
   tmp->child = NULL;
+  
+  /* add this conditional node to the parent */
+  egxp_node_add_conditional_node (tmp->parent, tmp);
+  
+
   return tmp;
 }
 
 
+Egxp_ConditionalNode * egxp_conditional_node_new_with_condition (Egxp_Node * parent, Egxp_Condition * cond) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_conditional_node_new_with_condition\n");
+#endif
+  assert(parent && cond);
+
+  Egxp_ConditionalNode * tmp = egxp_conditional_node_new (parent);
+  egxp_conditional_node_add_condition (tmp, cond);
+  
+  return tmp;
+}
+
 void egxp_conditional_node_free (Egxp_ConditionalNode * c) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_conditional_node_free\n");
 #endif
   assert (c);
   
+  /* free the structure */
   if (c->child) egxp_child_node_free (c->child);
   if (c->conditions) ecore_list_destroy (c->conditions);
   free (c);
 }
+
+
+void egxp_conditional_node_add_condition (Egxp_ConditionalNode * cn, Egxp_Condition * cond) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_conditional_node_add_condition\n");
+#endif
+  
+  assert (cn && cond);
+  
+  /* check if the conditions lists is created */
+  if (cn->conditions == NULL) {
+    cn->conditions = ecore_list_new ();
+    ecore_list_set_free_cb (cn->conditions, free);
+  }
+  
+  /* append the condition */
+  ecore_list_append (cn->conditions, cond);
+}
+
+void egxp_conditional_node_set_cb (Egxp_ConditionalNode * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
+  #ifdef EGXP_DEBUG
+  printf("TRACE: egxp_conditional_node_set_callback\n");
+#endif 
+
+  assert (n);
+  
+  /* check if the child node is created */
+  if (n->child == NULL) n->child = egxp_child_node_new ();
+  
+  /* set the attributes */
+  n->child->begin_func = begin;
+  n->child->end_func = end;
+}
+
+
+void egxp_conditional_node_add_child_node (Egxp_ConditionalNode * parent, Egxp_Node * child) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_conditional_node_add_child_node\n");
+#endif
+  assert (parent && child);
+
+  /* check if the child node is created */
+  if (parent->child == NULL) parent->child = egxp_child_node_new ();
+
+  /* add the node to the child element */
+  egxp_child_node_add_node (parent->child, child);
+}

Modified: src/egxp/egxp_conditional_node.h
===================================================================
--- src/egxp/egxp_conditional_node.h	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_conditional_node.h	2005-02-07 19:32:30 UTC (rev 4)
@@ -11,8 +11,37 @@
  */
 Egxp_ConditionalNode * egxp_conditional_node_new (Egxp_Node * parent);
 
+Egxp_ConditionalNode * egxp_conditional_node_new_with_condition (Egxp_Node * parent, Egxp_Condition * cond);
 
 
+/**
+ * Free the memory of the ConditionalNode Structure
+ */
 void egxp_conditional_node_free (Egxp_ConditionalNode * c);
 
+
+/**
+ * Add a condition to the condition list
+ * - If the condition list is not created, we create it.
+ * @param cn: the conditional node
+ * @param cond: the condition to add
+ */
+void egxp_conditional_node_add_condition (Egxp_ConditionalNode * cn, Egxp_Condition * cond);
+
+
+/**
+ * Add the callback function to the node
+ * @param begin:
+ * @param end:
+ */
+void egxp_conditional_node_set_cb (Egxp_ConditionalNode * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
+
+
+/**
+ * Add a node to the node
+ * @param parent: the parent node
+ * @param end: the child node
+ */
+void egxp_conditional_node_add_child_node (Egxp_ConditionalNode * parent, Egxp_Node * child);
+
 #endif

Modified: src/egxp/egxp_node.c
===================================================================
--- src/egxp/egxp_node.c	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_node.c	2005-02-07 19:32:30 UTC (rev 4)
@@ -5,6 +5,7 @@
 #include <Ecore_Data.h>
 
 #include "egxp_child_node.h"
+#include "egxp_conditional_node.h"
 #include "egxp_node.h"
 
 Egxp_Node * egxp_node_new (const unsigned int tag) {
@@ -36,7 +37,7 @@
 }
 
 
-void egxp_node_set_callback (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
+void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_node_set_callback\n");
 #endif 
@@ -64,3 +65,18 @@
   /* add the node to the child element */
   egxp_child_node_add_node (parent->child, child);  
 }
+
+
+void egxp_node_add_conditional_node (Egxp_Node * parent, Egxp_ConditionalNode * child) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_node_add_conditional_node\n");
+#endif
+  assert (parent && child);
+
+  if (parent->conditions == NULL) {
+    parent->conditions = ecore_list_new ();
+    ecore_list_set_free_cb (parent->conditions, egxp_conditional_node_free);
+  }
+  
+  ecore_list_append (parent->conditions, child);
+}

Modified: src/egxp/egxp_node.h
===================================================================
--- src/egxp/egxp_node.h	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_node.h	2005-02-07 19:32:30 UTC (rev 4)
@@ -22,7 +22,7 @@
  * @param begin:
  * @param end:
  */
-void egxp_node_set_callback (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
+void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
 
 
 /**
@@ -33,4 +33,12 @@
 void egxp_node_add_child_node (Egxp_Node * parent, Egxp_Node * child);
 
 
+/**
+ * Add a Conditional node to the node
+ * @param parent: the parent node
+ * @param end: the child node
+ */
+void egxp_node_add_conditional_node (Egxp_Node * parent, Egxp_ConditionalNode * child);
+
+
 #endif

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_opcode.c	2005-02-07 19:32:30 UTC (rev 4)
@@ -37,7 +37,7 @@
 }
 
 
-unsigned int egxp_opcode_add (Egxp_Opcode * op, const char * name) {
+int egxp_opcode_add (Egxp_Opcode * op, const char * name) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_opcode_add\n");
 #endif
@@ -45,7 +45,7 @@
   assert (op && name);
   
   /* allocate the memory for the id */
-  unsigned int * id = (unsigned int*) malloc (sizeof (unsigned int));
+  int * id = (int*) malloc (sizeof (int));
   *id = op->id++;
   
   /* add the new element */
@@ -85,7 +85,7 @@
 }
 
 
-const char * egxp_opcode_get_string (Egxp_Opcode * op, const unsigned int id) {
+const char * egxp_opcode_get_string (Egxp_Opcode * op, const int id) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_opcode_get_string\n");
 #endif
@@ -99,13 +99,20 @@
 }
 
 
-const unsigned int * egxp_opcode_get_id (const Egxp_Opcode *op, const char * name) {
+const int egxp_opcode_get_id (const Egxp_Opcode *op, const char * name) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_opcode_get_id\n");
 #endif
   assert (op && name);
 
-  return ((int*)ecore_hash_get (op->string_id, (char*)name));
+  int * tmp = ecore_hash_get (op->string_id, (char*)name);
+  if (!tmp) {
+    printf("ERROR: opcode %s seems to has no id\n"); 
+    assert (0);
+    return -1;
+  }
+  
+  return *tmp;
 }
 
 

Modified: src/egxp/egxp_opcode.h
===================================================================
--- src/egxp/egxp_opcode.h	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/egxp_opcode.h	2005-02-07 19:32:30 UTC (rev 4)
@@ -42,7 +42,7 @@
  * @param name: The string representation
  * @return the newly created id.
  */
-unsigned int egxp_opcode_add (Egxp_Opcode * op, const char * name);
+int egxp_opcode_add (Egxp_Opcode * op, const char * name);
 
 
 /**
@@ -60,7 +60,7 @@
  * @param id: The id
  * @return: the string id
  */
-const char * egxp_opcode_get_string (Egxp_Opcode * op, const unsigned int id);
+const char * egxp_opcode_get_string (Egxp_Opcode * op, const int id);
 
 
 /**
@@ -69,7 +69,7 @@
  * @param id: The id
  * @return: the string id
  */
-const unsigned int * egxp_opcode_get_id (const Egxp_Opcode *op, const char * name);
+const int egxp_opcode_get_id (const Egxp_Opcode *op, const char * name);
 
 
 /**

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-06 22:18:47 UTC (rev 3)
+++ src/egxp/test.c	2005-02-07 19:32:30 UTC (rev 4)
@@ -11,8 +11,8 @@
   Egxp_Node * n1 = NULL;
   Egxp_Node * n2 = NULL;
   Egxp_Node * n3 = NULL;
-  Egxp_Condition * c1 = NULL;
-
+  Egxp_ConditionalNode * c1 = NULL;
+  
   /* define basics grammar */
   egxp_opcode_add (ph->opcodes, "stream");
   egxp_opcode_add (ph->opcodes, "jabber:iq:auth");
@@ -27,17 +27,23 @@
   egxp_opcode_display (ph->opcodes);
 
   /* define the protocol */
-  ph->root = egxp_node_new (*egxp_opcode_get_id (ph->opcodes, "stream"));
+  ph->root = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "stream"));
   
   /* add the iq part as example */
-  n1 = egxp_node_new (*egxp_opcode_get_id (ph->opcodes, "iq"));
+  n1 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
   egxp_node_add_child_node (ph->root, n1);
-  
+  egxp_node_set_cb (n11, NULL, NULL);
+
   /* add iq type = get */
-  c1 = egxp_condition_new (*egxp_opcode_get_id (ph->opcodes, "type"),
-			   *egxp_opcode_get_id (ph->opcodes, "get"));
+  c1 = egxp_conditional_node_new_with_condition (n1, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
+									 egxp_opcode_get_id (ph->opcodes, "get")));
+  egxp_conditional_node_set_cb (c1, NULL, NULL);
   
-  
+  /* add iq type = set */
+  c1 = egxp_conditional_node_new_with_condition (n1, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
+									 egxp_opcode_get_id (ph->opcodes, "set")));
+  egxp_conditional_node_set_cb (c1, NULL, NULL);
+
   /* free opcode */
   egxp_free (ph);
   



From jol at sheep.berlios.de  Mon Feb  7 21:18:24 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Mon, 7 Feb 2005 21:18:24 +0100
Subject: [Eim-svn] r5 - src/egxp
Message-ID: <200502072018.j17KIOsi012795@sheep.berlios.de>

Author: jol
Date: 2005-02-07 21:18:23 +0100 (Mon, 07 Feb 2005)
New Revision: 5

Modified:
   src/egxp/egxp_child_node.c
   src/egxp/test.c
Log:
- fix warning and a typo


Modified: src/egxp/egxp_child_node.c
===================================================================
--- src/egxp/egxp_child_node.c	2005-02-07 19:32:30 UTC (rev 4)
+++ src/egxp/egxp_child_node.c	2005-02-07 20:18:23 UTC (rev 5)
@@ -45,5 +45,5 @@
   }
   
   /* so now we can add it */
-  ecore_hash_set (cn->childs, c->tag, c);
+  ecore_hash_set (cn->childs, &c->tag, c);
 }

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-07 19:32:30 UTC (rev 4)
+++ src/egxp/test.c	2005-02-07 20:18:23 UTC (rev 5)
@@ -32,7 +32,7 @@
   /* add the iq part as example */
   n1 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
   egxp_node_add_child_node (ph->root, n1);
-  egxp_node_set_cb (n11, NULL, NULL);
+  egxp_node_set_cb (n1, NULL, NULL);
 
   /* add iq type = get */
   c1 = egxp_conditional_node_new_with_condition (n1, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),



From jol at sheep.berlios.de  Mon Feb  7 23:52:16 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Mon, 7 Feb 2005 23:52:16 +0100
Subject: [Eim-svn] r6 - / src/egxp
Message-ID: <200502072252.j17MqGDL006831@sheep.berlios.de>

Author: jol
Date: 2005-02-07 23:52:12 +0100 (Mon, 07 Feb 2005)
New Revision: 6

Added:
   src/egxp/egxp_protocol_handler.c
   src/egxp/egxp_protocol_handler.h
Modified:
   ChangeLog
   TODO
   configure.ac
   src/egxp/Makefile.am
   src/egxp/egxp.c
   src/egxp/egxp.h
   src/egxp/egxp_child_node.c
   src/egxp/egxp_child_node.h
   src/egxp/egxp_condition.c
   src/egxp/egxp_condition.h
   src/egxp/egxp_conditional_node.c
   src/egxp/egxp_conditional_node.h
   src/egxp/egxp_message.c
   src/egxp/egxp_message.h
   src/egxp/egxp_node.c
   src/egxp/egxp_node.h
   src/egxp/egxp_node_struct.h
   src/egxp/egxp_opcode.c
   src/egxp/egxp_opcode.h
Log:
- add Egxp_ProtocolHandler
- configure.ac add depends on expat
- add the GPL in each source file
	


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-07 20:18:23 UTC (rev 5)
+++ ChangeLog	2005-02-07 22:52:12 UTC (rev 6)
@@ -2,6 +2,9 @@
 	- do not return pointer with egxp_opcode_get_id
 	- add functions to egxp_conditional_node with some helper function
 	- update the test example
+	- add Egxp_ProtocolHandler
+	- configure.ac add depends on expat
+	- add the GPL in each source file
 	
 2005-02-06(jol):
 	- fix a memleak from egxp_free

Modified: TODO
===================================================================
--- TODO	2005-02-07 20:18:23 UTC (rev 5)
+++ TODO	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,2 +1,3 @@
 - Change the Egxp_ChildNode to Egxp_BaseNode
 - Egxp_Node must inherit from Egxp_BaseNode
+- Continue the ProtocolHandler stuff

Modified: configure.ac
===================================================================
--- configure.ac	2005-02-07 20:18:23 UTC (rev 5)
+++ configure.ac	2005-02-07 22:52:12 UTC (rev 6)
@@ -20,6 +20,10 @@
 
 
 # PKG_CHECK_MODULES(IDN, libidn >= 0.4.1)
+
+
+
+dnl Check for ecore
 AC_ARG_WITH(ecore-config, [  --with-ecore-config=ECORE_CONFIG  use ecore-config specified ],
 [ ECORE_CONFIG=$withval;
   echo "using "$ECORE_CONFIG" for ecore-config"; ],
@@ -33,6 +37,40 @@
 AC_SUBST(ecore_cflags)
 
 
+
+dnl Check for expat
+EXPAT_INCLUDE=""
+EXPAT_LIB="-lexpat"
+EXPAT_SUBDIR=""
+LIBEXPAT="-lexpat"
+
+have_expat_lib=no
+have_expat_include=no
+
+AC_CHECK_HEADER(expat.h, [have_expat_include=yes])
+
+if test x$have_expat_include = xno; then
+    AC_MSG_ERROR(
+    [*** Unable to find expat header file! (http://expat.sourceforge.net)]
+    [Please install the library and header files if you want to link to the shared library.]
+    )
+fi
+
+AC_CHECK_LIB(expat, XML_ParserCreate, have_expat_lib=yes)
+
+if test x$have_expat_lib = xno; then
+   AC_MSG_ERROR(
+    [*** Unable to find expat xml library! (http://expat.sourceforge.net)]
+    [Please install the library and header files if you want to link to the shared library.]
+    )
+fi
+
+AC_SUBST(EXPAT_INCLUDE)
+AC_SUBST(EXPAT_LIB)
+AC_SUBST(EXPAT_SUBDIR)
+AC_SUBST(LIBEXPAT)
+
+
 AC_OUTPUT([
 Makefile
 src/Makefile

Modified: src/egxp/Makefile.am
===================================================================
--- src/egxp/Makefile.am	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/Makefile.am	2005-02-07 22:52:12 UTC (rev 6)
@@ -17,7 +17,8 @@
 	egxp_node.h          \
 	egxp_opcode.h        \
 	egxp.h               \
-	egxp_conditional_node.h
+	egxp_conditional_node.h \
+	egxp_protocol_handler.h
 
 
 libegxp_la_SOURCES = \
@@ -27,7 +28,8 @@
 	egxp_node.c         \
 	egxp_opcode.c       \
 	egxp.c              \
-	egxp_conditional_node.c
+	egxp_conditional_node.c \
+	egxp_protocol_handler.c
 
-libegxp_la_LIBADD = $(ecore_libs) $(IDN_LIBS) -lexpat
-libegxp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS)
+libegxp_la_LIBADD = $(ecore_libs) $(IDN_LIBS) $(EXPAT_LIB)
+libegxp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE)

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,24 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
 #include <assert.h>
 #include <stdlib.h>
 #include "egxp.h"
@@ -7,8 +28,18 @@
   printf("TRACE: egxp_new\n");
 #endif
   Egxp * tmp = EGXP(malloc (sizeof(Egxp)));
+  /* define the opcode */
   tmp->opcodes = egxp_opcode_new ();
+  
+  /* the root of the protocol */
   tmp->root = NULL;
+  
+  /* initialize the user data */
+  tmp->user_data = NULL;
+  
+  /* define the protocol handler */
+  tmp->protocol_handler = egxp_protocol_handler_new (tmp);
+
   return tmp;
 }
 
@@ -18,7 +49,12 @@
   printf("TRACE: egxp_free\n");
 #endif
   assert (e);
+  /* free opcode */
   egxp_opcode_free (e->opcodes);
+  /* free node */
   if (e->root) egxp_node_free(e->root);
+  /* free protocol handler */
+  if (e->protocol_handler) egxp_protocol_handler_free (e->protocol_handler);
+  
   free (e);
 }

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,24 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
 #ifndef egxp_header_h_
 #define egxp_header_h_
 
@@ -8,7 +29,9 @@
 #include "egxp_condition.h"
 #include "egxp_message.h"
 #include "egxp_conditional_node.h"
+#include "egxp_protocol_handler.h"
 
+
 typedef struct _Egxp Egxp;
 #define EGXP(o) ((Egxp*)o)
 struct _Egxp {
@@ -17,6 +40,12 @@
   
   /* root node */
   Egxp_Node * root;
+
+  /* the protocol handler */
+  Egxp_ProtocolHandler * protocol_handler;
+
+  /* specific user data */
+  void * user_data;
 };
 
 

Modified: src/egxp/egxp_child_node.c
===================================================================
--- src/egxp/egxp_child_node.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_child_node.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 #include <stdlib.h>
 

Modified: src/egxp/egxp_child_node.h
===================================================================
--- src/egxp/egxp_child_node.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_child_node.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef egxp_childnode_header_h_
 #define egxp_childnode_header_h_
 

Modified: src/egxp/egxp_condition.c
===================================================================
--- src/egxp/egxp_condition.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_condition.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 #include <stdio.h>
 

Modified: src/egxp/egxp_condition.h
===================================================================
--- src/egxp/egxp_condition.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_condition.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef egxp_condition_header_h_
 #define egxp_condition_header_h_
 

Modified: src/egxp/egxp_conditional_node.c
===================================================================
--- src/egxp/egxp_conditional_node.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_conditional_node.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 #include <stdlib.h>
 #include <Ecore_Data.h>

Modified: src/egxp/egxp_conditional_node.h
===================================================================
--- src/egxp/egxp_conditional_node.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_conditional_node.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef egxp_conditional_node_header_h_
 #define egxp_conditional_node_header_h_
 

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_message.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,24 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>

Modified: src/egxp/egxp_message.h
===================================================================
--- src/egxp/egxp_message.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_message.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef header_egxp_message_h
 #define header_egxp_message_h
 

Modified: src/egxp/egxp_node.c
===================================================================
--- src/egxp/egxp_node.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_node.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>

Modified: src/egxp/egxp_node.h
===================================================================
--- src/egxp/egxp_node.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_node.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef egxp_node_header_h_
 #define egxp_node_header_h_
 

Modified: src/egxp/egxp_node_struct.h
===================================================================
--- src/egxp/egxp_node_struct.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_node_struct.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,24 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
 #ifndef EGXP_NODE_STRUCT_H_
 #define EGXP_NODE_STRUCT_H_
 

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_opcode.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>

Modified: src/egxp/egxp_opcode.h
===================================================================
--- src/egxp/egxp_opcode.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_opcode.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef egxp_opcode_header_h_
 #define egxp_opcode_header_h_
 

Added: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_protocol_handler.c	2005-02-07 22:52:12 UTC (rev 6)
@@ -0,0 +1,108 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <assert.h>
+#include "egxp.h"
+#include "egxp_protocol_handler.h"
+
+
+/**
+ * XML Parser Callback
+ */
+void egxp_protocol_handler_start_element(void *userData, const char *name, const char **atts);
+void egxp_protocol_handler_end_element(void *userData, const char *name);
+void egxp_protocol_handler_char_data (void *userData, const XML_Char *s, int len);
+
+
+Egxp_ProtocolHandler * egxp_protocol_handler_new (struct _Egxp * e) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_new\n");
+#endif 
+  
+  assert (e);
+  
+  /* create and initialize the protocol handler */
+  Egxp_ProtocolHandler * tmp = EGXP_PROTOCOLHANDLER (malloc (sizeof(Egxp_ProtocolHandler)));
+  tmp->current_msg = NULL;
+
+  /* initialize the xml parser */
+  tmp->parser = XML_ParserCreate(NULL);
+  XML_SetUserData(tmp->parser, e);
+  XML_SetElementHandler(tmp->parser, 
+			egxp_protocol_handler_start_element, 
+			egxp_protocol_handler_end_element);
+  XML_SetCharacterDataHandler(tmp->parser,  egxp_protocol_handler_char_data);
+  
+  return tmp;
+}
+
+void egxp_protocol_handler_free (Egxp_ProtocolHandler * ph) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_free\n");
+#endif 
+  
+  assert (ph);
+  
+  /* need to free the parser */
+  if (ph->parser) XML_ParserFree(ph->parser);
+
+  /* do we need to free the message ? */
+  if (ph->current_msg) {
+    // ???
+  }
+  
+  free (ph);
+}
+
+
+
+
+
+
+
+void egxp_protocol_handler_start_element(void *userData, const char *name, const char **atts) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_start_element\n");
+#endif
+  assert (userData && name);
+  
+  /* really hard stuff here, we need to keep in a stack the protocol evolution
+     in order to call the correct callback */
+
+  /* we need to store the message hierarchy here (current_msg) */
+  
+}
+
+void egxp_protocol_handler_end_element(void *userData, const char *name) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_end_element\n");
+#endif
+  assert (userData && name);
+
+}
+
+void egxp_protocol_handler_char_data (void *userData, const XML_Char *s, int len) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_char_data\n");
+#endif
+  assert (userData);
+  
+  
+}

Added: src/egxp/egxp_protocol_handler.h
===================================================================
--- src/egxp/egxp_protocol_handler.h	2005-02-07 20:18:23 UTC (rev 5)
+++ src/egxp/egxp_protocol_handler.h	2005-02-07 22:52:12 UTC (rev 6)
@@ -0,0 +1,60 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef egxp_protocol_handler_header_h_
+#define egxp_protocol_handler_header_h_
+
+#include <expat.h>
+#include "egxp_message.h"
+
+struct _Egxp;
+
+typedef struct _Egxp_ProtocolHandler Egxp_ProtocolHandler;
+#define EGXP_PROTOCOLHANDLER(o) ((Egxp_ProtocolHandler*)o)
+struct _Egxp_ProtocolHandler {
+  
+  /* the current message */
+  Egxp_Message * current_msg;
+
+  /* the XML Parser */
+  XML_Parser parser;
+};
+
+
+/**
+ * Allocate the protocol handler structure
+ *  - initialize the XML Parser and set Egxp struct as a user data of
+ *    the xml parser.
+ * @param e: the Egxp structure sets as user data for the xml parser
+ */
+Egxp_ProtocolHandler * egxp_protocol_handler_new (struct _Egxp * e);
+
+
+/**
+ * Free the protocol handler
+ * @param ph: the protocol handler to be freed.
+ */
+void egxp_protocol_handler_free (Egxp_ProtocolHandler * ph);
+
+
+
+
+
+#endif



From jol at sheep.berlios.de  Wed Feb  9 22:16:12 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Wed, 9 Feb 2005 22:16:12 +0100
Subject: [Eim-svn] r7 - / src/egxp
Message-ID: <200502092116.j19LGCQg024912@sheep.berlios.de>

Author: jol
Date: 2005-02-09 22:16:10 +0100 (Wed, 09 Feb 2005)
New Revision: 7

Removed:
   src/egxp/egxp_child_node.c
   src/egxp/egxp_child_node.h
   src/egxp/egxp_conditional_node.c
   src/egxp/egxp_conditional_node.h
Modified:
   ChangeLog
   TODO
   src/egxp/Makefile.am
   src/egxp/egxp.c
   src/egxp/egxp.h
   src/egxp/egxp_condition.c
   src/egxp/egxp_condition.h
   src/egxp/egxp_node.c
   src/egxp/egxp_node.h
   src/egxp/egxp_node_struct.h
   src/egxp/egxp_opcode.c
   src/egxp/egxp_protocol_handler.c
   src/egxp/egxp_protocol_handler.h
   src/egxp/test.c
Log:
- Remove all complexe stuff, in fact i've remove child* and conditional* because they were too much complexe. I've replaced all the stuff in a simple structure
- During the Egxp_Opcode creation add automaticly the __ROOT__ opcode. It will be used by the egxp as initial node.
- During the Egxp creation add a root node __ROOT__




Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-07 22:52:12 UTC (rev 6)
+++ ChangeLog	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,3 +1,11 @@
+2005-02-09(jol):
+	- Remove all complexe stuff, in fact i've remove child* and conditional* because they were too much complexe. I've replaced
+	all the stuff in a simple structure.
+
+2005-02-08(jol):
+	- During the Egxp_Opcode creation add automaticly the __ROOT__ opcode. It will be used by the egxp as initial node.
+	- During the Egxp creation add a root node __ROOT__
+	
 2005-02-07(jol):
 	- do not return pointer with egxp_opcode_get_id
 	- add functions to egxp_conditional_node with some helper function

Modified: TODO
===================================================================
--- TODO	2005-02-07 22:52:12 UTC (rev 6)
+++ TODO	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,3 +1,3 @@
 - Change the Egxp_ChildNode to Egxp_BaseNode
 - Egxp_Node must inherit from Egxp_BaseNode
-- Continue the ProtocolHandler stuff
+- Should change the egxp_message to handle integer tag instead of char * tag.

Modified: src/egxp/Makefile.am
===================================================================
--- src/egxp/Makefile.am	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/Makefile.am	2005-02-09 21:16:10 UTC (rev 7)
@@ -13,22 +13,18 @@
 	egxp_condition.h     \
 	egxp_message.h       \
 	egxp_node_struct.h   \
-	egxp_child_node.h    \
 	egxp_node.h          \
 	egxp_opcode.h        \
 	egxp.h               \
-	egxp_conditional_node.h \
 	egxp_protocol_handler.h
 
 
 libegxp_la_SOURCES = \
 	egxp_condition.c    \
 	egxp_message.c      \
-	egxp_child_node.c   \
 	egxp_node.c         \
 	egxp_opcode.c       \
 	egxp.c              \
-	egxp_conditional_node.c \
 	egxp_protocol_handler.c
 
 libegxp_la_LIBADD = $(ecore_libs) $(IDN_LIBS) $(EXPAT_LIB)

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -32,14 +32,16 @@
   tmp->opcodes = egxp_opcode_new ();
   
   /* the root of the protocol */
-  tmp->root = NULL;
+  tmp->root = egxp_node_new (egxp_opcode_get_id (tmp->opcodes, 
+						      "__ROOT__"));
   
+  
   /* initialize the user data */
   tmp->user_data = NULL;
   
   /* define the protocol handler */
   tmp->protocol_handler = egxp_protocol_handler_new (tmp);
-
+  
   return tmp;
 }
 

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -23,12 +23,10 @@
 #define egxp_header_h_
 
 #include "egxp_node_struct.h"
-#include "egxp_child_node.h"
 #include "egxp_node.h"
 #include "egxp_opcode.h"
 #include "egxp_condition.h"
 #include "egxp_message.h"
-#include "egxp_conditional_node.h"
 #include "egxp_protocol_handler.h"
 
 

Deleted: src/egxp/egxp_child_node.c
===================================================================
--- src/egxp/egxp_child_node.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_child_node.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,69 +0,0 @@
-/*
-   $Id$
-
-   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
-   Part of the Eim Project http://eim.berlios.de
-
-   Eim is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   Eim is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Eim; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#include <assert.h>
-#include <stdlib.h>
-
-#include <Ecore_Data.h>
-
-#include "egxp_node.h"
-#include "egxp_child_node.h"
-
-Egxp_ChildNode * egxp_child_node_new () {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_child_node_new\n");
-#endif
-  
-  Egxp_ChildNode * tmp = EGXP_CHILDNODE(malloc(sizeof(Egxp_ChildNode)));
-  tmp->begin_func = NULL;
-  tmp->end_func = NULL;
-  tmp->childs = NULL;
-  
-  return tmp;
-}
-
-
-void egxp_child_node_free (Egxp_ChildNode * cn) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_child_node_free\n");
-#endif
-
-  assert(cn != NULL);
-  if (cn->childs) ecore_hash_destroy (cn->childs);
-  free (cn);
-}
-
-
-void egxp_child_node_add_node (Egxp_ChildNode * cn, Egxp_Node * c) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_child_node_add_node\n");
-#endif
-
-  assert (cn && c);
-
-  /* if not defined we create it */
-  if (cn->childs == NULL) {
-    cn->childs = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
-    ecore_hash_set_free_value (cn->childs, (Ecore_Free_Cb)egxp_node_free);
-  }
-  
-  /* so now we can add it */
-  ecore_hash_set (cn->childs, &c->tag, c);
-}

Deleted: src/egxp/egxp_child_node.h
===================================================================
--- src/egxp/egxp_child_node.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_child_node.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,47 +0,0 @@
-/*
-   $Id$
-
-   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
-   Part of the Eim Project http://eim.berlios.de
-
-   Eim is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   Eim is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Eim; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef egxp_childnode_header_h_
-#define egxp_childnode_header_h_
-
-#include "egxp_node_struct.h"
-
-/**
- * Create an initialize a new child node
- */
-Egxp_ChildNode * egxp_child_node_new ();
-
-
-/**
- * Free a child node
- */
-void egxp_child_node_free (Egxp_ChildNode * cn);
-
-
-/**
- * Add a node to the child node.
- *  - if the hash map is not allocated we initialize it.
- * @param cn: the child node
- * @param c: the node to add in the hash list
- */
-void egxp_child_node_add_node (Egxp_ChildNode * cn, Egxp_Node * c);
-
-
-#endif

Modified: src/egxp/egxp_condition.c
===================================================================
--- src/egxp/egxp_condition.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_condition.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -44,7 +44,7 @@
 }
 
 
-unsigned char egxp_condition_equals (Egxp_Condition * condition, const unsigned int key, const unsigned int value) {
+unsigned char egxp_condition_equals (Egxp_Condition * condition, const int key, const int value) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_condition_equals\n");
 #endif

Modified: src/egxp/egxp_condition.h
===================================================================
--- src/egxp/egxp_condition.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_condition.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -38,7 +38,7 @@
 /**
  * Test if the EgxpCondition is equal to the id and the value
  */
-unsigned char egxp_condition_equals (Egxp_Condition * condition, const unsigned int key, const unsigned int value);
+unsigned char egxp_condition_equals (Egxp_Condition * condition, const int key, const int value);
 
  
 #endif

Deleted: src/egxp/egxp_conditional_node.c
===================================================================
--- src/egxp/egxp_conditional_node.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_conditional_node.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,118 +0,0 @@
-/*
-   $Id$
-
-   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
-   Part of the Eim Project http://eim.berlios.de
-
-   Eim is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   Eim is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Eim; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#include <assert.h>
-#include <stdlib.h>
-#include <Ecore_Data.h>
-
-#include "egxp_child_node.h"
-#include "egxp_node.h"
-#include "egxp_conditional_node.h"
-
-Egxp_ConditionalNode * egxp_conditional_node_new (Egxp_Node * parent) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_new\n");
-#endif
-  assert (parent);
-  
-  /* create and initialize the structure */
-  Egxp_ConditionalNode * tmp = EGXP_CONDITIONALNODE(malloc (sizeof(Egxp_ConditionalNode)));
-  tmp->parent = parent;
-  tmp->conditions = NULL;
-  tmp->child = NULL;
-  
-  /* add this conditional node to the parent */
-  egxp_node_add_conditional_node (tmp->parent, tmp);
-  
-
-  return tmp;
-}
-
-
-Egxp_ConditionalNode * egxp_conditional_node_new_with_condition (Egxp_Node * parent, Egxp_Condition * cond) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_new_with_condition\n");
-#endif
-  assert(parent && cond);
-
-  Egxp_ConditionalNode * tmp = egxp_conditional_node_new (parent);
-  egxp_conditional_node_add_condition (tmp, cond);
-  
-  return tmp;
-}
-
-void egxp_conditional_node_free (Egxp_ConditionalNode * c) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_free\n");
-#endif
-  assert (c);
-  
-  /* free the structure */
-  if (c->child) egxp_child_node_free (c->child);
-  if (c->conditions) ecore_list_destroy (c->conditions);
-  free (c);
-}
-
-
-void egxp_conditional_node_add_condition (Egxp_ConditionalNode * cn, Egxp_Condition * cond) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_add_condition\n");
-#endif
-  
-  assert (cn && cond);
-  
-  /* check if the conditions lists is created */
-  if (cn->conditions == NULL) {
-    cn->conditions = ecore_list_new ();
-    ecore_list_set_free_cb (cn->conditions, free);
-  }
-  
-  /* append the condition */
-  ecore_list_append (cn->conditions, cond);
-}
-
-void egxp_conditional_node_set_cb (Egxp_ConditionalNode * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
-  #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_set_callback\n");
-#endif 
-
-  assert (n);
-  
-  /* check if the child node is created */
-  if (n->child == NULL) n->child = egxp_child_node_new ();
-  
-  /* set the attributes */
-  n->child->begin_func = begin;
-  n->child->end_func = end;
-}
-
-
-void egxp_conditional_node_add_child_node (Egxp_ConditionalNode * parent, Egxp_Node * child) {
-#ifdef EGXP_DEBUG
-  printf("TRACE: egxp_conditional_node_add_child_node\n");
-#endif
-  assert (parent && child);
-
-  /* check if the child node is created */
-  if (parent->child == NULL) parent->child = egxp_child_node_new ();
-
-  /* add the node to the child element */
-  egxp_child_node_add_node (parent->child, child);
-}

Deleted: src/egxp/egxp_conditional_node.h
===================================================================
--- src/egxp/egxp_conditional_node.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_conditional_node.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -1,67 +0,0 @@
-/*
-   $Id$
-
-   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
-   Part of the Eim Project http://eim.berlios.de
-
-   Eim is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   Eim is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with Eim; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-*/
-#ifndef egxp_conditional_node_header_h_
-#define egxp_conditional_node_header_h_
-
-#include "egxp_node_struct.h"
-
-
-/**
- * Initialize a conditional node.
- *  - you need to specify the parent.
- * @param parent: The "parent"
- */
-Egxp_ConditionalNode * egxp_conditional_node_new (Egxp_Node * parent);
-
-Egxp_ConditionalNode * egxp_conditional_node_new_with_condition (Egxp_Node * parent, Egxp_Condition * cond);
-
-
-/**
- * Free the memory of the ConditionalNode Structure
- */
-void egxp_conditional_node_free (Egxp_ConditionalNode * c);
-
-
-/**
- * Add a condition to the condition list
- * - If the condition list is not created, we create it.
- * @param cn: the conditional node
- * @param cond: the condition to add
- */
-void egxp_conditional_node_add_condition (Egxp_ConditionalNode * cn, Egxp_Condition * cond);
-
-
-/**
- * Add the callback function to the node
- * @param begin:
- * @param end:
- */
-void egxp_conditional_node_set_cb (Egxp_ConditionalNode * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
-
-
-/**
- * Add a node to the node
- * @param parent: the parent node
- * @param end: the child node
- */
-void egxp_conditional_node_add_child_node (Egxp_ConditionalNode * parent, Egxp_Node * child);
-
-#endif

Modified: src/egxp/egxp_node.c
===================================================================
--- src/egxp/egxp_node.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_node.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -24,79 +24,105 @@
 
 #include <Ecore_Data.h>
 
-#include "egxp_child_node.h"
-#include "egxp_conditional_node.h"
+#include "egxp_condition.h"
 #include "egxp_node.h"
 
-Egxp_Node * egxp_node_new (const unsigned int tag) {
+
+Egxp_Node * egxp_node_new (const int tag) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_node_new\n");
+  printf("TRACE: egxp_node__base_new\n");
 #endif 
 
   Egxp_Node * tmp = EGXP_NODE(malloc(sizeof(Egxp_Node)));
   
+  /* initialize the node */
   tmp->tag = tag;
+  tmp->parent = NULL;
   
-  tmp->child = NULL;
+  tmp->begin_cb = NULL;
+  tmp->end_cb = NULL;
+  
   tmp->conditions = NULL;
   
+  tmp->childs = NULL;
+  
   return tmp;
 }
 
 
-void egxp_node_free (Egxp_Node *n) {
+
+void egxp_node_free (Egxp_Node * n) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_node_free\n");
 #endif 
-
   assert (n);
   
-  if (n->child) egxp_child_node_free (n->child);
-  if (n->conditions) ecore_list_destroy (n->conditions);
+  if (n->conditions) ecore_hash_destroy (n->conditions);
+  if (n->childs) ecore_hash_destroy (n->childs);
   free (n);
 }
 
 
+
 void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_node_set_callback\n");
+  printf("TRACE: egxp_node_set_cb\n");
 #endif 
-
+  
   assert (n);
   
-  /* check if the child node is created */
-  if (n->child == NULL) n->child = egxp_child_node_new ();
-  
   /* set the attributes */
-  n->child->begin_func = begin;
-  n->child->end_func = end;
+  n->begin_cb = begin;
+  n->end_cb = end;
 }
 
 
-void egxp_node_add_child_node (Egxp_Node * parent, Egxp_Node * child) {
+void egxp_node_add_condition (Egxp_Node * cn, Egxp_Condition * cond) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_node_add_child_node\n");
+  printf("TRACE: egxp_node_add_condition\n");
 #endif
-  assert (parent && child);
-
-  /* check if the child node is created */
-  if (parent->child == NULL) parent->child = egxp_child_node_new ();
-
-  /* add the node to the child element */
-  egxp_child_node_add_node (parent->child, child);  
+  
+  assert (cn && cond);
+  
+  /* check if the conditions lists is created */
+  if (cn->conditions == NULL) {
+    cn->conditions = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
+    ecore_hash_set_free_value (cn->conditions, (Ecore_Free_Cb)egxp_condition_free);
+  }
+  
+  /* append the condition */
+  ecore_hash_set (cn->conditions, (int*)cond->key, cond);
 }
 
 
-void egxp_node_add_conditional_node (Egxp_Node * parent, Egxp_ConditionalNode * child) {
+void egxp_node_add_child (Egxp_Node * parent, Egxp_Node * child) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_node_add_conditional_node\n");
+  printf("TRACE: egxp_node_add_child\n");
 #endif
+  
   assert (parent && child);
 
-  if (parent->conditions == NULL) {
-    parent->conditions = ecore_list_new ();
-    ecore_list_set_free_cb (parent->conditions, egxp_conditional_node_free);
+  if (parent->childs == NULL) {
+    /* create a hash */
+    parent->childs = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
+    /* destroy each element */
+    ecore_hash_set_free_value (parent->childs, (Ecore_Free_Cb)ecore_list_destroy);
   }
   
-  ecore_list_append (parent->conditions, child);
+  /* try to get the list for the special tag */
+  Ecore_List * ltmp = ecore_hash_get (parent->childs, (int*)child->tag);
+  
+  if (ltmp == NULL) {
+    /* doesn't exist, so create it */
+    ltmp = ecore_list_new ();
+    ecore_list_set_free_cb (ltmp,(Ecore_Free_Cb)egxp_node_free);
+    
+    /* append the list to the hash, hash is indexed by the tag id */
+    ecore_hash_set (parent->childs, (int*)child->tag, ltmp);
+  }
+  
+  /* now append the child to the list */
+  ecore_list_append (ltmp, child);
+  /* set the parent for the child */
+  child->parent = parent;
 }

Modified: src/egxp/egxp_node.h
===================================================================
--- src/egxp/egxp_node.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_node.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -23,42 +23,19 @@
 
 #include "egxp_node_struct.h"
 
+/****************************************************************/
+/****************************************************************/
+/****************************************************************/
+Egxp_Node * egxp_node_new (const int tag);
 
-/**
- * Create an initialize the structure
- * @param tag: the id of this node
- */
-Egxp_Node * egxp_node_new (const unsigned int tag);
+void egxp_node_free (Egxp_Node * n);
 
-
-/**
- * Free the memory ...
- */
-void egxp_node_free (Egxp_Node *n);
-
-
-/**
- * Add the callback function to the node
- * @param begin:
- * @param end:
- */
 void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
 
 
-/**
- * Add a node to the node
- * @param parent: the parent node
- * @param end: the child node
- */
-void egxp_node_add_child_node (Egxp_Node * parent, Egxp_Node * child);
+void egxp_node_add_condition (Egxp_Node* cn, Egxp_Condition * cond);
 
 
-/**
- * Add a Conditional node to the node
- * @param parent: the parent node
- * @param end: the child node
- */
-void egxp_node_add_conditional_node (Egxp_Node * parent, Egxp_ConditionalNode * child);
+void egxp_node_add_child (Egxp_Node * parent, Egxp_Node * child);
 
-
 #endif

Modified: src/egxp/egxp_node_struct.h
===================================================================
--- src/egxp/egxp_node_struct.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_node_struct.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -32,49 +32,36 @@
 typedef void (*egxp_callback_ptr)(Egxp_Message *, void*);
 
 
-typedef struct _Egxp_ChildNode Egxp_ChildNode;
-#define EGXP_CHILDNODE(o) ((Egxp_ChildNode*)o)
-struct _Egxp_ChildNode {
-  Ecore_Hash * childs; /* hash map, the key is the tag, value is a Egxp node */
 
-  egxp_callback_ptr * begin_func; /* called when the start tag appears */
-  egxp_callback_ptr * end_func;   /* called when the end tag appears */
+typedef struct _Egxp_Condition Egxp_Condition;
+#define EGXP_CONDITION(o) ((Egxp_Condition*)o)
+struct _Egxp_Condition {
+  unsigned int key; /* the id of the key */
+  unsigned int value; /* the id of the value */
 };
 
 
 /**
- * This is the main structure of Egxp. This structure keeps the tag id.
+ * This structure is really more simple
  */
 typedef struct _Egxp_Node Egxp_Node;
 #define EGXP_NODE(o) ((Egxp_Node*)o)
 struct _Egxp_Node {
-  Egxp_ChildNode * child; /* this is a pointer on a child, it's used when no specific condition
-			     are specified */
+  /* the tag */
+  int tag;
   
-  unsigned int tag; /* this is the id of the tag */
+  /* the parent */
+  Egxp_Node * parent;
   
-  Ecore_List * conditions; /* this is a list of conditionnal Node attributes -> epgx_conditional node */
-};
-
-
-typedef struct _Egxp_Condition Egxp_Condition;
-#define EGXP_CONDITION(o) ((Egxp_Condition*)o)
-struct _Egxp_Condition {
-  unsigned int key; /* the id of the key */
-  unsigned int value; /* the id of the value */
-};
-
-
-
-typedef struct _Egxp_ConditionalNode Egxp_ConditionalNode;
-#define EGXP_CONDITIONALNODE(o) ((Egxp_ConditionalNode*)o)
-struct _Egxp_ConditionalNode {
-  Egxp_ChildNode * child;
+  /* the callback */
+  egxp_callback_ptr * begin_cb;
+  egxp_callback_ptr * end_cb; 
   
-  Egxp_Node * parent; /* the parent of this node, it's necessary to know the tag, but maybe 
-			 useless ... */
+  /* conditions are inside a hash */
+  Ecore_Hash * conditions;
   
-  Ecore_List * conditions; /* this is the list of the condition */
+  /* the child. It's a hash<tag_id, list<Egxp_NodeBase*>> */
+  Ecore_Hash * childs;
 };
 
 #endif

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_opcode.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -38,6 +38,9 @@
   tmp->id = 0;
   tmp->need_update = 0;
 
+  /* add automaticly the __ROOT__ element */
+  egxp_opcode_add (tmp, "__ROOT__");
+    
   return tmp;
 }
 

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_protocol_handler.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -49,6 +49,9 @@
 			egxp_protocol_handler_start_element, 
 			egxp_protocol_handler_end_element);
   XML_SetCharacterDataHandler(tmp->parser,  egxp_protocol_handler_char_data);
+
+  /* initialize the protocol stack */
+  tmp->protocol_stack = NULL;
   
   return tmp;
 }
@@ -65,7 +68,7 @@
 
   /* do we need to free the message ? */
   if (ph->current_msg) {
-    // ???
+    egxp_message_free (ph->current_msg);
   }
   
   free (ph);
@@ -83,11 +86,71 @@
 #endif
   assert (userData && name);
   
+  /* cast the egxp variable */
+  Egxp * eg = EGXP (userData);
+  Egxp_ProtocolHandler * ph = eg->protocol_handler;
+  int i;
+  char use_callback = 0;
+
+  assert (eg && ph);
+
   /* really hard stuff here, we need to keep in a stack the protocol evolution
      in order to call the correct callback */
 
   /* we need to store the message hierarchy here (current_msg) */
   
+  /* build the message with the specific id */
+  /* NOTE we should update the egxp_message to use integer id */
+  Egxp_Message * message = egxp_message_new ((char*) name);
+  
+  /* process attributes */
+  for (i = 0; atts[i]; i += 2)
+    egxp_message_add_attribute (message,
+				egxp_message_attribute_new((char*)atts[i],(char*) atts[i+1]));
+  
+  /* attach the message */
+  if (ph->current_msg == NULL) {
+    ph->current_msg = message;
+  } else {
+    egxp_message_add_child (ph->current_msg, message);
+    ph->current_msg = message;
+  }
+
+  /* need to detect which callback to call, if an element in not 
+     inside the protocol */
+  if (ph->protocol_stack == NULL) {
+    /* if null it's because it's the first time we are here 
+       so we need to check inside  protocol tree if the tag
+       is the root.
+    */
+    assert (eg->root);
+    
+    if (!strcmp (egxp_opcode_get_string (eg->opcodes, eg->root->tag),
+		 name)) {
+      /* they are equals, we begin :p */
+      ph->protocol_stack = eg->root;
+      use_callback = 1;
+    } else {
+      /* seems to be an error */
+    }
+  } else {
+    /* 
+       we check if the protocol_stack element has the name as
+       child node, if the tag name is present we are on the 
+       good way, otherwise it seems that the implementation is 
+       not completed
+    */
+    
+  }
+
+  
+  /*
+    if all is ok, we can call the callback associated to this
+    message (check the use_callback value)
+  */
+  if (use_callback) {
+    assert (ph->protocol_stack);
+  }
 }
 
 void egxp_protocol_handler_end_element(void *userData, const char *name) {

Modified: src/egxp/egxp_protocol_handler.h
===================================================================
--- src/egxp/egxp_protocol_handler.h	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/egxp_protocol_handler.h	2005-02-09 21:16:10 UTC (rev 7)
@@ -22,7 +22,9 @@
 #define egxp_protocol_handler_header_h_
 
 #include <expat.h>
+
 #include "egxp_message.h"
+#include "egxp_node_struct.h"
 
 struct _Egxp;
 
@@ -35,6 +37,9 @@
 
   /* the XML Parser */
   XML_Parser parser;
+
+  /* the protocol stack */
+  Egxp_Node * protocol_stack;
 };
 
 

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-07 22:52:12 UTC (rev 6)
+++ src/egxp/test.c	2005-02-09 21:16:10 UTC (rev 7)
@@ -11,7 +11,6 @@
   Egxp_Node * n1 = NULL;
   Egxp_Node * n2 = NULL;
   Egxp_Node * n3 = NULL;
-  Egxp_ConditionalNode * c1 = NULL;
   
   /* define basics grammar */
   egxp_opcode_add (ph->opcodes, "stream");
@@ -25,25 +24,27 @@
 
   /* display information about opcode */
   egxp_opcode_display (ph->opcodes);
-
-  /* define the protocol */
-  ph->root = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "stream"));
   
-  /* add the iq part as example */
-  n1 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
-  egxp_node_add_child_node (ph->root, n1);
-  egxp_node_set_cb (n1, NULL, NULL);
-
-  /* add iq type = get */
-  c1 = egxp_conditional_node_new_with_condition (n1, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
-									 egxp_opcode_get_id (ph->opcodes, "get")));
-  egxp_conditional_node_set_cb (c1, NULL, NULL);
+  n1 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "stream"));
+  egxp_node_add_child (ph->root, n1);
   
-  /* add iq type = set */
-  c1 = egxp_conditional_node_new_with_condition (n1, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
-									 egxp_opcode_get_id (ph->opcodes, "set")));
-  egxp_conditional_node_set_cb (c1, NULL, NULL);
-
+  /* add iq tag */
+  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
+  egxp_node_add_child (n1, n2);
+  
+  /* add iq tag + type=set */
+  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
+  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
+							egxp_opcode_get_id (ph->opcodes, "set")));
+  egxp_node_add_child (n1, n2);
+  
+  
+  /* add iq tag + type=get */
+  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
+  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
+							egxp_opcode_get_id (ph->opcodes, "get")));
+  egxp_node_add_child (n1, n2);
+  
   /* free opcode */
   egxp_free (ph);
   



From jol at sheep.berlios.de  Thu Feb 10 17:42:22 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Thu, 10 Feb 2005 17:42:22 +0100
Subject: [Eim-svn] r8 - / src/egxp
Message-ID: <200502101642.j1AGgMRW020182@sheep.berlios.de>

Author: jol
Date: 2005-02-10 17:42:20 +0100 (Thu, 10 Feb 2005)
New Revision: 8

Modified:
   ChangeLog
   src/egxp/egxp_message.c
   src/egxp/egxp_node.c
   src/egxp/egxp_node.h
   src/egxp/egxp_node_struct.h
   src/egxp/egxp_opcode.c
   src/egxp/egxp_protocol_handler.c
   src/egxp/egxp_protocol_handler.h
   src/egxp/test.c
Log:
- replace free statement with the EFL FREE macro
- fix some error around the callback stuff ...
- continue the work on egxp_protocol_handler. Now, we are able to
  get the protocol node in function of the received message.
- add some documentation around egxp_node



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-09 21:16:10 UTC (rev 7)
+++ ChangeLog	2005-02-10 16:42:20 UTC (rev 8)
@@ -1,3 +1,10 @@
+2005-02-10(jol):
+	- replace free statement with the EFL FREE macro
+	- fix some error around the callback stuff ...
+	- continue the work on egxp_protocol_handler. Now, we are able to
+	get the protocol node in function of the received message.
+	- add some documentation around egxp_node
+	
 2005-02-09(jol):
 	- Remove all complexe stuff, in fact i've remove child* and conditional* because they were too much complexe. I've replaced
 	all the stuff in a simple structure.
@@ -18,4 +25,4 @@
 	- fix a memleak from egxp_free
 	- add Egxp_ConditionalNode
 	- add TODO file
-	
\ No newline at end of file
+	

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_message.c	2005-02-10 16:42:20 UTC (rev 8)
@@ -56,7 +56,7 @@
 void egxp_message_free (Egxp_Message * m) {
   if (m == NULL) return;
   
-  free (m->tagname);
+  FREE (m->tagname);
   ecore_list_destroy (m->attributes);
   ecore_list_destroy (m->childs);
   
@@ -65,7 +65,7 @@
     egxp_message_remove_child (m->parent, m);
   }
   
-  free (m);
+  FREE (m);
 }
 
 Egxp_Message * egxp_message_get_child (Egxp_Message *m, char * tagname) {
@@ -238,7 +238,7 @@
       buf_len += len;
       buf = (char*) realloc (buf, buf_len);
       buf = strncat (buf, tmp_buf, len);
-      free (tmp_buf);
+      FREE (tmp_buf);
     }
     
     // the termination tag
@@ -258,7 +258,7 @@
   if (m == NULL) return;
   char * buf = egxp_message_to_xml (m, 1);
   printf("%s\n", buf);
-  free(buf);
+  FREE(buf);
 }
 
 
@@ -280,7 +280,7 @@
 void egxp_message_attribute_free (Egxp_MessageAttribute * ma) {
   if (ma == NULL) return;
   
-  free (ma->key);
-  free (ma->value);
-  free (ma);
+  FREE (ma->key);
+  FREE (ma->value);
+  FREE (ma);
 }

Modified: src/egxp/egxp_node.c
===================================================================
--- src/egxp/egxp_node.c	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_node.c	2005-02-10 16:42:20 UTC (rev 8)
@@ -30,7 +30,7 @@
 
 Egxp_Node * egxp_node_new (const int tag) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_node__base_new\n");
+  printf("TRACE: egxp_node_new\n");
 #endif 
 
   Egxp_Node * tmp = EGXP_NODE(malloc(sizeof(Egxp_Node)));
@@ -57,14 +57,14 @@
 #endif 
   assert (n);
   
-  if (n->conditions) ecore_hash_destroy (n->conditions);
+  if (n->conditions) ecore_list_destroy (n->conditions);
   if (n->childs) ecore_hash_destroy (n->childs);
-  free (n);
+  FREE (n);
 }
 
 
 
-void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end) {
+void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr begin, egxp_callback_ptr end) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_node_set_cb\n");
 #endif 
@@ -86,15 +86,47 @@
   
   /* check if the conditions lists is created */
   if (cn->conditions == NULL) {
-    cn->conditions = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
-    ecore_hash_set_free_value (cn->conditions, (Ecore_Free_Cb)egxp_condition_free);
+    cn->conditions = ecore_list_new ();
+    ecore_list_set_free_cb (cn->conditions, (Ecore_Free_Cb)egxp_condition_free);
   }
   
   /* append the condition */
-  ecore_hash_set (cn->conditions, (int*)cond->key, cond);
+  ecore_list_append (cn->conditions, cond);
 }
 
 
+void egxp_node_add_in_order (Ecore_DList * l, Egxp_Node * n) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_node_add_in_order\n");
+#endif
+
+  assert (l && n);
+  Egxp_Node * pn = NULL;
+
+  /* before doing anything, check if there is condition,
+     if not we add it to the end if the list */
+  if (n->conditions == NULL || ecore_list_nodes (l) == 0) {
+    ecore_dlist_append (l, n);
+    return;
+  }
+  
+  
+  /* go to the first node */
+  ecore_dlist_goto_first(l);
+  
+  while((pn = EGXP_NODE(ecore_dlist_next(l))) != NULL) {
+    if (pn->conditions == NULL || 
+        ecore_dlist_nodes (n->conditions) > ecore_dlist_nodes(pn->conditions)) {
+      ecore_dlist_previous(l);
+      ecore_dlist_insert (l, n);
+      return;
+    }
+  }
+  
+  ecore_dlist_append (l, n);
+}
+
+
 void egxp_node_add_child (Egxp_Node * parent, Egxp_Node * child) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_node_add_child\n");
@@ -106,23 +138,24 @@
     /* create a hash */
     parent->childs = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
     /* destroy each element */
-    ecore_hash_set_free_value (parent->childs, (Ecore_Free_Cb)ecore_list_destroy);
+    ecore_hash_set_free_value (parent->childs, (Ecore_Free_Cb)ecore_dlist_destroy);
   }
   
   /* try to get the list for the special tag */
-  Ecore_List * ltmp = ecore_hash_get (parent->childs, (int*)child->tag);
+  Ecore_DList * ltmp = ECORE_DLIST (ecore_hash_get (parent->childs, (int*)child->tag));
   
   if (ltmp == NULL) {
     /* doesn't exist, so create it */
-    ltmp = ecore_list_new ();
-    ecore_list_set_free_cb (ltmp,(Ecore_Free_Cb)egxp_node_free);
+    ltmp = ecore_dlist_new ();
+    ecore_dlist_set_free_cb (ltmp,(Ecore_Free_Cb)egxp_node_free);
     
     /* append the list to the hash, hash is indexed by the tag id */
     ecore_hash_set (parent->childs, (int*)child->tag, ltmp);
   }
   
   /* now append the child to the list */
-  ecore_list_append (ltmp, child);
+  egxp_node_add_in_order (ltmp, child);
+
   /* set the parent for the child */
   child->parent = parent;
 }

Modified: src/egxp/egxp_node.h
===================================================================
--- src/egxp/egxp_node.h	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_node.h	2005-02-10 16:42:20 UTC (rev 8)
@@ -26,16 +26,45 @@
 /****************************************************************/
 /****************************************************************/
 /****************************************************************/
+
+/**
+ * Create a new node.
+ * @param tag: The tag id for this node
+ * @return: the newly created node
+ */
 Egxp_Node * egxp_node_new (const int tag);
 
+
+/**
+ * Free a node
+ * @param n: Deallocate the memory used by the node
+ */
 void egxp_node_free (Egxp_Node * n);
 
-void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr * begin, egxp_callback_ptr * end);
 
+/**
+ * Set the callback to the node.
+ * This callback are called when the node is processed by the protocol handler.
+ * @param n: the node
+ * @param begin: The begin callback
+ * @param end: the end callback
+ */
+void egxp_node_set_cb (Egxp_Node * n, egxp_callback_ptr begin, egxp_callback_ptr end);
 
+
+/**
+ * Add condition to this node.
+ * @param cn: The node
+ * @param cond: The condition to add
+ */
 void egxp_node_add_condition (Egxp_Node* cn, Egxp_Condition * cond);
 
 
+/**
+ * Add a child to the node
+ * @param parent: The parent node
+ * @param child: The child to add to the parent
+ */
 void egxp_node_add_child (Egxp_Node * parent, Egxp_Node * child);
 
 #endif

Modified: src/egxp/egxp_node_struct.h
===================================================================
--- src/egxp/egxp_node_struct.h	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_node_struct.h	2005-02-10 16:42:20 UTC (rev 8)
@@ -54,11 +54,11 @@
   Egxp_Node * parent;
   
   /* the callback */
-  egxp_callback_ptr * begin_cb;
-  egxp_callback_ptr * end_cb; 
+  egxp_callback_ptr begin_cb;
+  egxp_callback_ptr end_cb; 
   
-  /* conditions are inside a hash */
-  Ecore_Hash * conditions;
+  /* conditions are inside a list */
+  Ecore_List * conditions;
   
   /* the child. It's a hash<tag_id, list<Egxp_NodeBase*>> */
   Ecore_Hash * childs;

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_opcode.c	2005-02-10 16:42:20 UTC (rev 8)
@@ -126,12 +126,11 @@
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_opcode_get_id\n");
 #endif
-  assert (op && name);
+  assert (op);
 
   int * tmp = ecore_hash_get (op->string_id, (char*)name);
   if (!tmp) {
-    printf("ERROR: opcode %s seems to has no id\n"); 
-    assert (0);
+    printf("ERROR: unknown opcode %s.\n"); 
     return -1;
   }
   

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_protocol_handler.c	2005-02-10 16:42:20 UTC (rev 8)
@@ -51,8 +51,9 @@
   XML_SetCharacterDataHandler(tmp->parser,  egxp_protocol_handler_char_data);
 
   /* initialize the protocol stack */
-  tmp->protocol_stack = NULL;
-  
+  tmp->protocol_stack = e->root;
+  assert (tmp->protocol_stack != NULL);
+
   return tmp;
 }
 
@@ -91,14 +92,10 @@
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   int i;
   char use_callback = 0;
+  Egxp_Node * node = NULL;
 
   assert (eg && ph);
 
-  /* really hard stuff here, we need to keep in a stack the protocol evolution
-     in order to call the correct callback */
-
-  /* we need to store the message hierarchy here (current_msg) */
-  
   /* build the message with the specific id */
   /* NOTE we should update the egxp_message to use integer id */
   Egxp_Message * message = egxp_message_new ((char*) name);
@@ -115,42 +112,22 @@
     egxp_message_add_child (ph->current_msg, message);
     ph->current_msg = message;
   }
-
-  /* need to detect which callback to call, if an element in not 
-     inside the protocol */
-  if (ph->protocol_stack == NULL) {
-    /* if null it's because it's the first time we are here 
-       so we need to check inside  protocol tree if the tag
-       is the root.
-    */
-    assert (eg->root);
-    
-    if (!strcmp (egxp_opcode_get_string (eg->opcodes, eg->root->tag),
-		 name)) {
-      /* they are equals, we begin :p */
-      ph->protocol_stack = eg->root;
-      use_callback = 1;
-    } else {
-      /* seems to be an error */
-    }
+  
+  /* manage protocol */
+  assert (ph->protocol_stack);
+  
+  /* try to get the Egxp_Node correspond to the tag id and parameter */
+  node = egxp_protocol_handler_get_node (ph->protocol_stack, message, eg->opcodes);
+  
+  if (node == NULL) {
+    /* do nothing */
   } else {
-    /* 
-       we check if the protocol_stack element has the name as
-       child node, if the tag name is present we are on the 
-       good way, otherwise it seems that the implementation is 
-       not completed
-    */
+    /* update the hierarchy */
+    ph->protocol_stack = node;
     
+    /* take a look if it's possible to execute the callback */
+    if (node->begin_cb) node->begin_cb (message, eg);
   }
-
-  
-  /*
-    if all is ok, we can call the callback associated to this
-    message (check the use_callback value)
-  */
-  if (use_callback) {
-    assert (ph->protocol_stack);
-  }
 }
 
 void egxp_protocol_handler_end_element(void *userData, const char *name) {
@@ -169,3 +146,58 @@
   
   
 }
+
+
+
+Egxp_Node * egxp_protocol_handler_get_node (Egxp_Node * node, Egxp_Message * message, Egxp_Opcode * opcode) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_get_node\n");
+#endif
+  
+  assert (node && message);
+  Egxp_Node * ntmp = NULL;
+  if (node->childs == NULL) return NULL;
+  
+  /* get the good list */
+  Ecore_DList * ltmp = ecore_hash_get (node->childs,
+                                       (int*)egxp_opcode_get_id (opcode, message->tagname));
+  if (ltmp == NULL) return NULL;
+  
+  /* go to the first node */
+  ecore_dlist_goto_first(ltmp);
+  while ( (ntmp = ecore_dlist_next(ltmp)) != NULL) {
+    /* check if all conditions of the ntmp is inside the message */
+    if (ntmp->conditions == NULL) {
+      return ntmp;
+    }else {
+      Egxp_Condition * cond = NULL;
+      char condition_ok = 1;
+      ecore_list_goto_first (ntmp->conditions);
+      /* browse all condition of the node */
+      while ( (cond = ecore_list_next (ntmp->conditions)) != NULL) {
+        char * attr_val = egxp_message_get_attribute (message, (char*)egxp_opcode_get_string (opcode, cond->key));
+        /* if we have not found a condition */
+        if (attr_val == NULL) {
+          condition_ok = 0;
+          break;
+        }
+        
+        /* check now if the value is the correct value */
+        if( cond->value == egxp_opcode_get_id (opcode, attr_val)) {
+          FREE (attr_val);
+          continue;
+        } else {
+          FREE (attr_val);
+          condition_ok = 0;
+          break;
+        }
+      } 
+
+      /* check if the node is ok */
+      if (condition_ok) return ntmp;
+    }
+  }
+  
+  /* not found */
+  return NULL;
+}

Modified: src/egxp/egxp_protocol_handler.h
===================================================================
--- src/egxp/egxp_protocol_handler.h	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/egxp_protocol_handler.h	2005-02-10 16:42:20 UTC (rev 8)
@@ -60,6 +60,15 @@
 
 
 
+/**
+ * This method check if there is a child inside the node parameter which has 
+ * same properties than the message.
+ * 
+ * @param node : the node
+ * @param m: the message.
+ */
+Egxp_Node * egxp_protocol_handler_get_node (Egxp_Node * node, 
+                                            Egxp_Message * message,
+                                            Egxp_Opcode * opcode);
 
-
 #endif

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-09 21:16:10 UTC (rev 7)
+++ src/egxp/test.c	2005-02-10 16:42:20 UTC (rev 8)
@@ -7,46 +7,90 @@
 
 int main (int argc, char ** argv) {
   /* create the protocol grammar */
-  Egxp * ph = egxp_new ();
+  Egxp * eg = egxp_new ();
   Egxp_Node * n1 = NULL;
   Egxp_Node * n2 = NULL;
   Egxp_Node * n3 = NULL;
   
+  /******************************************************/
+  /******************************************************/
+  /*          CREATE THE BASICS OPCODES                 */
+  /******************************************************/
+  /******************************************************/
+  
+
   /* define basics grammar */
-  egxp_opcode_add (ph->opcodes, "stream");
-  egxp_opcode_add (ph->opcodes, "jabber:iq:auth");
+  egxp_opcode_add (eg->opcodes, "stream");
+  egxp_opcode_add (eg->opcodes, "jabber:iq:auth");
   
-  egxp_opcode_add (ph->opcodes, "iq");
-  egxp_opcode_add (ph->opcodes, "type");
-  egxp_opcode_add (ph->opcodes, "get");
-  egxp_opcode_add (ph->opcodes, "set");
+  egxp_opcode_add (eg->opcodes, "iq");
+  egxp_opcode_add (eg->opcodes, "type");
+  egxp_opcode_add (eg->opcodes, "get");
+  egxp_opcode_add (eg->opcodes, "set");
   
 
   /* display information about opcode */
-  egxp_opcode_display (ph->opcodes);
+  egxp_opcode_display (eg->opcodes);
   
-  n1 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "stream"));
-  egxp_node_add_child (ph->root, n1);
   
+
+  /******************************************************/
+  /******************************************************/
+  /*             CREATE THE PROTOCOL                    */
+  /******************************************************/
+  /******************************************************/
+  
+  /* add stream to the root */
+  n1 = egxp_node_new (egxp_opcode_get_id (eg->opcodes, "stream"));
+  egxp_node_add_child (eg->root, n1);
+  
   /* add iq tag */
-  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
+  n2 = egxp_node_new (egxp_opcode_get_id (eg->opcodes, "iq"));
   egxp_node_add_child (n1, n2);
   
   /* add iq tag + type=set */
-  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
-  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
-							egxp_opcode_get_id (ph->opcodes, "set")));
+  n2 = egxp_node_new (egxp_opcode_get_id (eg->opcodes, "iq"));
+  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, "type"),
+                                                   egxp_opcode_get_id (eg->opcodes, "set")));
   egxp_node_add_child (n1, n2);
   
-  
   /* add iq tag + type=get */
-  n2 = egxp_node_new (egxp_opcode_get_id (ph->opcodes, "iq"));
-  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (ph->opcodes, "type"),
-							egxp_opcode_get_id (ph->opcodes, "get")));
+  n2 = egxp_node_new (egxp_opcode_get_id (eg->opcodes, "iq"));
+  egxp_node_add_condition (n2, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, "type"),
+                                                   egxp_opcode_get_id (eg->opcodes, "get")));
   egxp_node_add_child (n1, n2);
   
+
+  /******************************************************/
+  /******************************************************/
+  /*            CREATE SOME MESSAGES                    */
+  /******************************************************/
+  /******************************************************/
+  
+  /* create a stream message without attribute */
+  Egxp_Message * mesg1 = egxp_message_new ("stream");
+  /* test if it's possible to get the node from the egxp protocol handler */
+  n1 = egxp_protocol_handler_get_node (eg->protocol_handler->protocol_stack,
+                                       mesg1, eg->opcodes);
+  printf("Get stream node from protocol handler(it should not be null): %X\n", n1); 
+  
+  /* free the message */
+  egxp_message_free (mesg1);
+  
+  
+
+  /* create a iq message with one attributes */
+  mesg1 = egxp_message_new ("iq");
+  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("type", "get"));
+  /* test if it's possible to get the node from the egxp protocol handler */
+  printf("Get iq node from protocol handler(it should not be null): %X\n",
+         egxp_protocol_handler_get_node (n1, mesg1, eg->opcodes));
+  /* free the message */
+  egxp_message_free (mesg1);
+  
+  
   /* free opcode */
-  egxp_free (ph);
+  egxp_free (eg);
   
   return 0;
 }



From jol at sheep.berlios.de  Thu Feb 10 17:54:15 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Thu, 10 Feb 2005 17:54:15 +0100
Subject: [Eim-svn] r9 - /
Message-ID: <200502101654.j1AGsFEn020717@sheep.berlios.de>

Author: jol
Date: 2005-02-10 17:54:13 +0100 (Thu, 10 Feb 2005)
New Revision: 9

Modified:
   TODO
Log:
Update TODO file


Modified: TODO
===================================================================
--- TODO	2005-02-10 16:42:20 UTC (rev 8)
+++ TODO	2005-02-10 16:54:13 UTC (rev 9)
@@ -1,3 +1,7 @@
-- Change the Egxp_ChildNode to Egxp_BaseNode
-- Egxp_Node must inherit from Egxp_BaseNode
+HIGH URGENCY
+- implement egxp_protocol_handler_end_element
+- implement egxp_protocol_handler_char_data
+- implement the receive callback to give data to the XML Parser
+
+LOW URGENCY
 - Should change the egxp_message to handle integer tag instead of char * tag.



From jol at sheep.berlios.de  Sat Feb 12 20:14:30 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Sat, 12 Feb 2005 20:14:30 +0100
Subject: [Eim-svn] r10 - / src/egxp
Message-ID: <200502121914.j1CJEUHU013323@sheep.berlios.de>

Author: jol
Date: 2005-02-12 20:14:29 +0100 (Sat, 12 Feb 2005)
New Revision: 10

Modified:
   ChangeLog
   TODO
   src/egxp/egxp_message.c
   src/egxp/egxp_protocol_handler.c
   src/egxp/egxp_protocol_handler.h
Log:
Now egxp seems to be runnable. We can start to make test to integrate the jabber protocol.

- factorize some code inside egxp_protocol_handler.
- finished the protocol handler xml part.



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-10 16:54:13 UTC (rev 9)
+++ ChangeLog	2005-02-12 19:14:29 UTC (rev 10)
@@ -1,3 +1,7 @@
+2005-02-12(jol):
+	- factorize some code inside egxp_protocol_handler.
+	- finished the protocol handler xml part.
+	
 2005-02-10(jol):
 	- replace free statement with the EFL FREE macro
 	- fix some error around the callback stuff ...

Modified: TODO
===================================================================
--- TODO	2005-02-10 16:54:13 UTC (rev 9)
+++ TODO	2005-02-12 19:14:29 UTC (rev 10)
@@ -1,7 +1,7 @@
 HIGH URGENCY
-- implement egxp_protocol_handler_end_element
-- implement egxp_protocol_handler_char_data
 - implement the receive callback to give data to the XML Parser
 
 LOW URGENCY
 - Should change the egxp_message to handle integer tag instead of char * tag.
+- Need some improvement in the egxp_message in order to limit the buffer copy ...
+

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-10 16:54:13 UTC (rev 9)
+++ src/egxp/egxp_message.c	2005-02-12 19:14:29 UTC (rev 10)
@@ -110,7 +110,6 @@
   ecore_list_goto_first(m->attributes);
   Egxp_MessageAttribute * list_item;
   while((list_item = (Egxp_MessageAttribute*)ecore_list_next(m->attributes)) != NULL) {
-    printf("DEBUG GET ATTRIBUTE Key: %s -- %s\n", key, list_item->key);
     if (strcmp (key, list_item->key) == 0)
       return strdup (list_item->value);
   }
@@ -182,15 +181,12 @@
   buf = strncat (buf, m->tagname, strlen (m->tagname));
   buf = strncat (buf, " ", 1);
   buf_len = len;
-
-  // process attribute
-  printf("DEBUG XML: %s\n", m->tagname);
-
+  
   ecore_list_goto_first(m->attributes);
   Egxp_MessageAttribute * list_item;
   while((list_item = (Egxp_MessageAttribute*)ecore_list_next(m->attributes)) != NULL) {
     // "key=value " +4 (don't forget "")
-    printf("DEBUG XML ATTRIBUTES: %s=%s\n",list_item->key, list_item->value);
+    // printf("DEBUG XML ATTRIBUTES: %s=%s\n",list_item->key, list_item->value);
     buf_len += strlen (list_item->key) + strlen (list_item->value) + 4;
     buf = (char*) realloc (buf, buf_len);
     // copy the key

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-10 16:54:13 UTC (rev 9)
+++ src/egxp/egxp_protocol_handler.c	2005-02-12 19:14:29 UTC (rev 10)
@@ -19,6 +19,7 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 #include <assert.h>
+#include <stdio.h>
 #include "egxp.h"
 #include "egxp_protocol_handler.h"
 
@@ -119,9 +120,7 @@
   /* try to get the Egxp_Node correspond to the tag id and parameter */
   node = egxp_protocol_handler_get_node (ph->protocol_stack, message, eg->opcodes);
   
-  if (node == NULL) {
-    /* do nothing */
-  } else {
+  if (node != NULL) {
     /* update the hierarchy */
     ph->protocol_stack = node;
     
@@ -136,25 +135,102 @@
 #endif
   assert (userData && name);
 
+  Egxp * eg = EGXP (userData);
+  Egxp_ProtocolHandler * ph = eg->protocol_handler;
+  
+  assert (eg && ph);
+  
+  /* check if the current message is equal to the current protocol stack node */
+  if (egxp_protocol_handler_equals (ph->protocol_stack, ph->current_msg, eg->opcodes)) {
+    /* if equals we can call the callback associated to the end and update the protocol_stack */
+    if (ph->protocol_stack->end_cb != NULL) ph->protocol_stack->end_cb (ph->current_msg, eg);
+    
+    /* goto the parent node */
+    ph->protocol_stack = ph->protocol_stack->parent;
+  
+    /* go to the parent message and destroy the current message */
+    Egxp_Message * old = ph->current_msg;
+    ph->current_msg = old->parent;
+    egxp_message_free (old);
+  } else {
+    ph->current_msg = ph->current_msg->parent;
+  }
 }
 
+
 void egxp_protocol_handler_char_data (void *userData, const XML_Char *s, int len) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_protocol_handler_char_data\n");
 #endif
-  assert (userData);
+  assert (userData && len >= 0);
+  /* cast the egxp variable */
+  Egxp * eg = EGXP (userData);
+  Egxp_ProtocolHandler * ph = eg->protocol_handler;
   
+  assert (eg && ph);
   
+  /* append data to the message */
+  egxp_message_append_data ( ph->current_msg, (char*) s, len);
 }
 
 
 
+
+char egxp_protocol_handler_condition_equals (Ecore_List * conditions, Egxp_Message * message, Egxp_Opcode * opcode) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_condition_equals\n");
+#endif
+  assert (message && opcode);
+
+  /* if the node has no condition we can conclude that they are equals */
+  if (conditions == NULL) return 1;
+  
+  /* compare the condition list */
+  Egxp_Condition * cond = NULL;
+  ecore_list_goto_first (conditions);
+  /* browse all condition of the node */
+  while ( (cond = ecore_list_next (conditions)) != NULL) {
+    char * attr_val = egxp_message_get_attribute (message, (char*)egxp_opcode_get_string (opcode, cond->key));
+    /* if we have not found a condition */
+    if (attr_val == NULL) {
+      return 0;
+    }
+    /* check now if the value is the correct value */
+    if( cond->value == egxp_opcode_get_id (opcode, attr_val)) {
+      FREE (attr_val);
+      continue;
+    } else {
+      FREE (attr_val);
+      return 0;
+    }
+  }
+  return 1;
+}
+
+
+char egxp_protocol_handler_equals (Egxp_Node * node, Egxp_Message * message, Egxp_Opcode * opcode) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_protocol_handler_equals\n");
+#endif
+  assert (node && message && opcode);
+
+  /* check if the tag are equals */
+  if (node->tag != egxp_opcode_get_id (opcode, message->tagname)) {
+    return 0;
+  }
+ 
+  /* return true if the conditions are equals */
+  return egxp_protocol_handler_condition_equals (node->conditions, message, opcode);
+}
+
+
+
 Egxp_Node * egxp_protocol_handler_get_node (Egxp_Node * node, Egxp_Message * message, Egxp_Opcode * opcode) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_protocol_handler_get_node\n");
 #endif
   
-  assert (node && message);
+  assert (node && message && opcode);
   Egxp_Node * ntmp = NULL;
   if (node->childs == NULL) return NULL;
   
@@ -167,37 +243,36 @@
   ecore_dlist_goto_first(ltmp);
   while ( (ntmp = ecore_dlist_next(ltmp)) != NULL) {
     /* check if all conditions of the ntmp is inside the message */
-    if (ntmp->conditions == NULL) {
+    if (egxp_protocol_handler_condition_equals (ntmp->conditions, message, opcode)) {
       return ntmp;
-    }else {
-      Egxp_Condition * cond = NULL;
-      char condition_ok = 1;
-      ecore_list_goto_first (ntmp->conditions);
-      /* browse all condition of the node */
-      while ( (cond = ecore_list_next (ntmp->conditions)) != NULL) {
-        char * attr_val = egxp_message_get_attribute (message, (char*)egxp_opcode_get_string (opcode, cond->key));
-        /* if we have not found a condition */
-        if (attr_val == NULL) {
-          condition_ok = 0;
-          break;
-        }
-        
-        /* check now if the value is the correct value */
-        if( cond->value == egxp_opcode_get_id (opcode, attr_val)) {
-          FREE (attr_val);
-          continue;
-        } else {
-          FREE (attr_val);
-          condition_ok = 0;
-          break;
-        }
-      } 
-
-      /* check if the node is ok */
-      if (condition_ok) return ntmp;
     }
   }
   
   /* not found */
   return NULL;
 }
+
+
+
+int egxp_protocol_handler_receive_server_cb (void *data, int type, Ecore_Con_Event_Server_Data *ev) {
+#ifdef EJAB_DEBUG
+  printf("TRACE: egxp_protocol_handler_receive_server_cb\n");
+#endif
+  
+  assert (data != NULL);
+  
+  Egxp * eg =  EGXP (data);
+  Egxp_ProtocolHandler * ph = eg->protocol_handler;
+  XML_Parser parser =  ph->parser;
+  
+  printf("Got server data %X [%d] (%s)\n", ev->server, ev->size, (char *)ev->data);
+  
+  if (XML_Parse(parser, (char*) ev->data, ev->size, 0) == XML_STATUS_ERROR) {
+    fprintf(stderr, "%s at line %d\n",
+	    XML_ErrorString(XML_GetErrorCode(parser)),
+	    XML_GetCurrentLineNumber(parser));
+    return 1;
+  }
+  
+  return 1;
+}

Modified: src/egxp/egxp_protocol_handler.h
===================================================================
--- src/egxp/egxp_protocol_handler.h	2005-02-10 16:54:13 UTC (rev 9)
+++ src/egxp/egxp_protocol_handler.h	2005-02-12 19:14:29 UTC (rev 10)
@@ -22,6 +22,7 @@
 #define egxp_protocol_handler_header_h_
 
 #include <expat.h>
+#include <Ecore_Con.h>
 
 #include "egxp_message.h"
 #include "egxp_node_struct.h"
@@ -71,4 +72,43 @@
                                             Egxp_Message * message,
                                             Egxp_Opcode * opcode);
 
+
+
+/**
+ * This method check if all elements of the conditions list are present 
+ * in the message attributes. If the conditions list is null, we conclude that
+ * the conditions list is equals to the message attributes.
+ * @param conditions: a list of Egxp_Condition object
+ * @param message: The message use to check the condition list
+ * @param opcode: The list of opcode defined.
+ * @return 1 is the condition list is equals, otherwise return 0.
+ */
+char egxp_protocol_handler_condition_equals (Ecore_List * conditions, 
+					     Egxp_Message * message, 
+					     Egxp_Opcode * opcode);
+
+
+/**
+ * Check if the node is equal to the message. Use the egxp_protocol_handler_condition_equals
+ * to check if the condition list is equal.
+ * @param node: The node to test
+ * @param message: The message to test
+ * @param opcode: The list of opcode defined
+ * @return 1 is the node and message are equals
+ */
+char egxp_protocol_handler_equals(Egxp_Node * node, 
+				  Egxp_Message * message, 
+				  Egxp_Opcode * opcode);
+
+
+/**
+ * This method should be useb by the ecore asynchronous mechanism in order to
+ * give xml data to the parser.
+ * @param data: Should be the Egxp type
+ * @param type: Type of the event (not used for now)
+ * @param ev: The event given by the ecore mechanism
+ * @return 1 (we need to take a look inside the ecore documentation ...)
+ */
+int egxp_protocol_handler_receive_server_cb (void *data, int type, Ecore_Con_Event_Server_Data *ev);
+
 #endif



From jol at sheep.berlios.de  Sun Feb 13 02:13:50 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Sun, 13 Feb 2005 02:13:50 +0100
Subject: [Eim-svn] r11 - / src src/egxp src/xmpp
Message-ID: <200502130113.j1D1DoIB017059@sheep.berlios.de>

Author: jol
Date: 2005-02-13 02:13:42 +0100 (Sun, 13 Feb 2005)
New Revision: 11

Added:
   src/xmpp/
   src/xmpp/Makefile.am
   src/xmpp/test.c
   src/xmpp/xmpp.c
   src/xmpp/xmpp.h
   src/xmpp/xmpp_callback.c
   src/xmpp/xmpp_callback.h
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
   src/xmpp/xmpp_struct.h
Modified:
   ChangeLog
   configure.ac
   src/Makefile.am
   src/egxp/Makefile.am
   src/egxp/egxp.c
   src/egxp/egxp.h
Log:
- begin the xmpp part.
- add the extension concept inside the Egxp structure



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-12 19:14:29 UTC (rev 10)
+++ ChangeLog	2005-02-13 01:13:42 UTC (rev 11)
@@ -1,3 +1,6 @@
+2005-02-13(jol):
+	- begin the xmpp part.
+	- add the extension concept inside the Egxp structure
 2005-02-12(jol):
 	- factorize some code inside egxp_protocol_handler.
 	- finished the protocol handler xml part.

Modified: configure.ac
===================================================================
--- configure.ac	2005-02-12 19:14:29 UTC (rev 10)
+++ configure.ac	2005-02-13 01:13:42 UTC (rev 11)
@@ -75,5 +75,6 @@
 Makefile
 src/Makefile
 src/egxp/Makefile
+src/xmpp/Makefile
 doc/Makefile
 ])

Modified: src/Makefile.am
===================================================================
--- src/Makefile.am	2005-02-12 19:14:29 UTC (rev 10)
+++ src/Makefile.am	2005-02-13 01:13:42 UTC (rev 11)
@@ -1 +1,2 @@
-SUBDIRS=egxp
+SUBDIRS=egxp xmpp
+

Modified: src/egxp/Makefile.am
===================================================================
--- src/egxp/Makefile.am	2005-02-12 19:14:29 UTC (rev 10)
+++ src/egxp/Makefile.am	2005-02-13 01:13:42 UTC (rev 11)
@@ -5,7 +5,7 @@
 test_LDADD = libegxp.la
 test_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS)
 
-lib_LTLIBRARIES = libegxp.la
+noinst_LTLIBRARIES = libegxp.la
 
 pkgincludeinputdir = $(pkgincludedir)/egxp
 

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-12 19:14:29 UTC (rev 10)
+++ src/egxp/egxp.c	2005-02-13 01:13:42 UTC (rev 11)
@@ -34,14 +34,16 @@
   /* the root of the protocol */
   tmp->root = egxp_node_new (egxp_opcode_get_id (tmp->opcodes, 
 						      "__ROOT__"));
-  
-  
+    
   /* initialize the user data */
   tmp->user_data = NULL;
   
   /* define the protocol handler */
   tmp->protocol_handler = egxp_protocol_handler_new (tmp);
-  
+
+  /* initialzie extension */
+  tmp->extensions = NULL;
+
   return tmp;
 }
 
@@ -57,6 +59,44 @@
   if (e->root) egxp_node_free(e->root);
   /* free protocol handler */
   if (e->protocol_handler) egxp_protocol_handler_free (e->protocol_handler);
+  /* free extension */
+  if (e->extensions) ecore_hash_destroy (e->extensions);
   
   free (e);
 }
+
+
+void egxp_extension_free (void * e) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_extension_free\n");
+#endif
+  assert (e);
+  
+  Egxp_Extension * ext = EGXP_EXTENSION(e);
+  ext->destroy (e);
+}
+
+void egxp_extension_register (Egxp * e, int id, void * ext) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_extension_register\n");
+#endif
+  assert (e && ext);
+
+  if (e->extensions == NULL) {
+    e->extensions = ecore_hash_new (ecore_direct_hash, ecore_direct_compare);
+    ecore_hash_set_free_value (e->extensions, egxp_extension_free);
+  }
+  
+  ecore_hash_set (e->extensions, (int*)id, ext);
+}
+
+
+void * egxp_extension_get (Egxp *e, int id) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_extension_get\n");
+#endif
+  assert (e && id);
+  assert (e->extensions);
+
+  return ecore_hash_get (e->extensions, (int*)id);
+}

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-12 19:14:29 UTC (rev 10)
+++ src/egxp/egxp.h	2005-02-13 01:13:42 UTC (rev 11)
@@ -22,6 +22,8 @@
 #ifndef egxp_header_h_
 #define egxp_header_h_
 
+#include <Ecore_Data.h>
+
 #include "egxp_node_struct.h"
 #include "egxp_node.h"
 #include "egxp_opcode.h"
@@ -42,11 +44,21 @@
   /* the protocol handler */
   Egxp_ProtocolHandler * protocol_handler;
 
+  /* contains data */
+  Ecore_Hash * extensions;
+
   /* specific user data */
   void * user_data;
 };
 
 
+typedef struct _Egxp_Extension Egxp_Extension;
+#define EGXP_EXTENSION(o) ((Egxp_Extension*)o)
+struct _Egxp_Extension {
+  Ecore_Free_Cb destroy;
+};
+
+
 /**
  * Allocate the Egxp structure
  * - allocate the opcodes structures 
@@ -60,4 +72,17 @@
  */
 void egxp_free (Egxp * e);
 
+
+/**
+ * Register an extension. It allows to store data, so when you define 
+ * other extension you can store you're structure inside
+ */
+void egxp_extension_register (Egxp * e, int id, void * ext);
+
+
+/**
+ * @return the extension
+ */
+void * egxp_extension_get (Egxp *e, int id);
+
 #endif

Added: src/xmpp/Makefile.am
===================================================================
--- src/xmpp/Makefile.am	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/Makefile.am	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,25 @@
+noinst_PROGRAMS = test
+
+test_SOURCES = \
+	test.c
+test_LDADD = \
+	-L$(top_srcdir)/src/egxp -legxp \
+	-lxmpp
+test_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) -I$(top_srcdir)/src
+
+
+noinst_LTLIBRARIES = libxmpp.la
+
+pkgincludeinputdir = $(pkgincludedir)/xmpp
+pkgincludeinput_HEADERS= \
+	xmpp_opcode.h    \
+	xmpp_callback.h  \
+	xmpp_struct.h    \
+	xmpp.h
+
+libxmpp_la_SOURCES = \
+	xmpp_opcode.c    \
+	xmpp_callback.c  \
+	xmpp.c
+
+libxmpp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE) -I$(top_srcdir)/src

Added: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/test.c	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,21 @@
+#include <stdio.h>
+
+#include "egxp/egxp.h"
+#include "xmpp.h"
+
+int main (int argc, char ** argv) {
+  
+  /* create the protocol grammar */
+  Egxp * eg = egxp_new ();
+  
+  /* init opcode */
+  xmpp_register (eg);
+
+  /* display opcode */
+  egxp_opcode_display (eg->opcodes);
+  
+  /* free opcode */
+  egxp_free (eg);
+  
+  return 0;
+}

Added: src/xmpp/xmpp.c
===================================================================
--- src/xmpp/xmpp.c	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp.c	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,50 @@
+#include <stdio.h>
+#include <assert.h>
+#include "xmpp.h"
+
+
+void xmpp_register (Egxp * eg) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_register\n");
+#endif
+
+  assert (eg);
+  
+  /* register opcode */
+  xmpp_opcode_init (eg);
+  /* initialize the Egxp Structure */
+  int id = egxp_opcode_add (eg->opcodes, XMPP_REGISTER);
+  Xmpp * tmp = xmpp_new (eg);
+  /* register the structure */
+  egxp_extension_register (eg, id, tmp);
+}
+
+
+
+Xmpp * xmpp_new (Egxp * eg) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_new\n");
+#endif
+
+  assert (eg);
+  
+  /* allocate the structure */
+  Xmpp * tmp = XMPP (malloc(sizeof (Xmpp)));
+  
+  /* define the destroy function */
+  tmp->extension.destroy = ECORE_FREE_CB(xmpp_free);
+  
+  /* return the xmpp */
+  return tmp;
+}
+
+
+void xmpp_free (Xmpp * x) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_free\n");
+#endif
+  
+  assert (x);
+  
+  FREE (x);
+}

Added: src/xmpp/xmpp.h
===================================================================
--- src/xmpp/xmpp.h	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp.h	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,33 @@
+#ifndef xmpp_header_h_
+#define xmpp_header_h_
+
+#include "egxp/egxp.h"
+
+#include "xmpp_struct.h"
+#include "xmpp_opcode.h"
+#include "xmpp_callback.h"
+
+
+#define XMPP_REGISTER "__XMPP_REGISTER__"
+
+/**
+ * Register the xmpp protocol
+ *  - initialize the xmpp structure
+ *  - register opcode and protocol node
+ * @param eg: The Egpx structure
+ */
+void xmpp_register (Egxp * eg);
+
+
+/**
+ * Initialize the xmpp structure.
+ */
+Xmpp * xmpp_new (Egxp * eg);
+
+
+/**
+ * Free memory
+ */
+void xmpp_free (Xmpp * x);
+
+#endif

Added: src/xmpp/xmpp_callback.c
===================================================================
--- src/xmpp/xmpp_callback.c	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp_callback.c	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,11 @@
+#include "xmpp_callback.h"
+
+
+void xmpp_callback_stream_begin_cb (Egxp_Message * msg, void * eg) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_callback_stream_begin_cb\n");
+#endif 
+  assert (msg && eg);
+  
+  
+}

Added: src/xmpp/xmpp_callback.h
===================================================================
--- src/xmpp/xmpp_callback.h	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp_callback.h	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,13 @@
+#ifndef xmpp_opcode_header_h_
+#define xmpp_opcode_header_h_
+
+#include "egxp/egxp_node_struct.h"
+
+
+/**
+ * Stream begin callback
+ */
+void xmpp_callback_stream_begin_cb (Egxp_Message * msg, void * eg);
+
+
+#endif

Added: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp_opcode.c	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,43 @@
+#include <assert.h>
+
+#include "egxp/egxp_node.h"
+
+#include "xmpp_opcode.h"
+
+void xmpp_opcode_init (Egxp * eg) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_opcode_init\n");
+#endif 
+  assert (eg && eg->opcodes);
+
+  /* *************** */
+  /* register opcode */
+  /* *************** */
+  /*     stream      */
+  egxp_opcode_add (eg->opcodes, XMPP_TAG_STREAM);
+  
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS_STREAM);
+  
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_XMLNS);
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_XMLNS_STREAM);
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_VERSION);
+  
+  
+  
+  /********************/
+  /********************/
+  /*  Protocol Init   */
+  /********************/
+  /********************/
+  /* define stream */
+  Egxp_Node * stream = egxp_node_new (egxp_opcode_get_id (eg->opcodes, XMPP_TAG_STREAM));
+  egxp_node_add_child (eg->root, stream);
+  
+  egxp_node_add_condition (stream, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_XMLNS),
+						       egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_STREAM_XMLNS)));
+  
+  egxp_node_add_condition (stream, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_XMLNS_STREAM),
+						       egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_STREAM_XMLNS_STREAM)));
+  
+}

Added: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp_opcode.h	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,39 @@
+#ifndef xmpp_core_header_h_
+#define xmpp_core_header_h_
+
+#include "egxp/egxp.h"
+
+/**
+ * Here we define the xmpp opcodes
+ */
+#define XMPP_TAG_STREAM "stream:stream"
+
+#define XMPP_ATT_XMLNS          "xmlns"
+#define XMPP_ATT_XMLNS_STREAM   "xmlns:stream"
+
+#define XMPP_VALUE_STREAM_XMLNS          "jabber:client"
+#define XMPP_VALUE_STREAM_XMLNS_STREAM   "http://etherx.jabber.org/streams"
+#define XMPP_VALUE_STREAM_VERSION        "1.0"
+
+
+
+#define XMPP_ATT_TYPE           "type"
+#define XMPP_ATT_TO             "to"
+#define XMPP_ATT_XMLNS          "xmlns"
+#define XMPP_ATT_VERSION        "version"
+#define XMPP_ATT_ID             "id"
+#define XMPP_ATT_JID            "jid"
+#define XMPP_ATT_FROM           "from"
+#define XMPP_ATT_NAME           "name"
+
+
+
+
+/**
+ * Add the xmpp opcode inside the opcode variable
+ * @param opcode: use to store xmpp opcode
+ */
+void xmpp_opcode_init (Egxp * eg);
+
+
+#endif

Added: src/xmpp/xmpp_struct.h
===================================================================
--- src/xmpp/xmpp_struct.h	2005-02-12 19:14:29 UTC (rev 10)
+++ src/xmpp/xmpp_struct.h	2005-02-13 01:13:42 UTC (rev 11)
@@ -0,0 +1,17 @@
+#ifndef xmpp_struct_header_h_
+#define xmpp_struct_header_h_
+
+#include <Ecore_Data.h>
+
+#include "egxp/egxp.h"
+
+typedef struct _Xmpp Xmpp;
+#define XMPP(o) ((Xmpp*)o)
+struct _Xmpp {
+  /* This variable is really important, it's used to destroy itself */
+  Egxp_Extension extension;
+  
+  int t;
+};
+
+#endif



From jol at sheep.berlios.de  Sun Feb 13 17:41:01 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Sun, 13 Feb 2005 17:41:01 +0100
Subject: [Eim-svn] r12 - / src/egxp src/xmpp
Message-ID: <200502131641.j1DGf1Ak023426@sheep.berlios.de>

Author: jol
Date: 2005-02-13 17:40:57 +0100 (Sun, 13 Feb 2005)
New Revision: 12

Added:
   src/egxp/egxp_connection.c
   src/egxp/egxp_connection.h
   src/xmpp/xmpp_jid.c
   src/xmpp/xmpp_jid.h
   src/xmpp/xmpp_message.c
   src/xmpp/xmpp_message.h
Modified:
   ChangeLog
   TODO
   src/egxp/Makefile.am
   src/egxp/egxp.c
   src/egxp/egxp.h
   src/xmpp/Makefile.am
   src/xmpp/test.c
   src/xmpp/xmpp.c
   src/xmpp/xmpp.h
   src/xmpp/xmpp_callback.c
   src/xmpp/xmpp_callback.h
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
   src/xmpp/xmpp_struct.h
Log:
- Add connection control inside egxp. So it's now possible to 
  connect/disconnect  and get/send message to a server.
- Add a first support to jid (malloc and free :)
- Add a beginning to send xmpp message.
- Update the xmpp test example. You can only connect to a server. 
  But the test code allow you to understand how the future will be to add 
  jabber extension protocol.
- Minor fix and improvement.



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-13 01:13:42 UTC (rev 11)
+++ ChangeLog	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,6 +1,15 @@
 2005-02-13(jol):
+	- Add connection control inside egxp. So it's now possible to connect/disconnect 
+	  and get/send message to a server.
+	- Add a first support to jid (malloc and free :)
+	- Add a beginning to send xmpp message.
+	- Update the xmpp test example. You can only connect to a server. 
+	  But the test code allow you to understand how the future will be to add 
+	  jabber extension protocol.
+	- Minor fix and improvement.
 	- begin the xmpp part.
 	- add the extension concept inside the Egxp structure
+	
 2005-02-12(jol):
 	- factorize some code inside egxp_protocol_handler.
 	- finished the protocol handler xml part.

Modified: TODO
===================================================================
--- TODO	2005-02-13 01:13:42 UTC (rev 11)
+++ TODO	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,5 +1,6 @@
 HIGH URGENCY
-- implement the receive callback to give data to the XML Parser
+- implement the xmpp_message_stream to give a connection example
+- implement the xmpp_callback_stream_begin_cb to show how handle received data
 
 LOW URGENCY
 - Should change the egxp_message to handle integer tag instead of char * tag.

Modified: src/egxp/Makefile.am
===================================================================
--- src/egxp/Makefile.am	2005-02-13 01:13:42 UTC (rev 11)
+++ src/egxp/Makefile.am	2005-02-13 16:40:57 UTC (rev 12)
@@ -16,7 +16,8 @@
 	egxp_node.h          \
 	egxp_opcode.h        \
 	egxp.h               \
-	egxp_protocol_handler.h
+	egxp_protocol_handler.h \
+	egxp_connection.h
 
 
 libegxp_la_SOURCES = \
@@ -25,7 +26,8 @@
 	egxp_node.c         \
 	egxp_opcode.c       \
 	egxp.c              \
-	egxp_protocol_handler.c
+	egxp_protocol_handler.c \
+	egxp_connection.c
 
 libegxp_la_LIBADD = $(ecore_libs) $(IDN_LIBS) $(EXPAT_LIB)
 libegxp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE)

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/egxp/egxp.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -23,6 +23,8 @@
 #include <stdlib.h>
 #include "egxp.h"
 
+typedef int (*Handler_Func) (void *data, int type, void *event);
+
 Egxp * egxp_new () {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_new\n");
@@ -41,6 +43,14 @@
   /* define the protocol handler */
   tmp->protocol_handler = egxp_protocol_handler_new (tmp);
 
+  /* register the callback function */
+  tmp->receive_cb = ecore_event_handler_add (ECORE_CON_EVENT_SERVER_DATA,
+					     (Handler_Func) egxp_protocol_handler_receive_server_cb,
+					     tmp);
+  
+  /* initialize the connection */
+  tmp->connection = NULL;
+
   /* initialzie extension */
   tmp->extensions = NULL;
 
@@ -55,13 +65,16 @@
   assert (e);
   /* free opcode */
   egxp_opcode_free (e->opcodes);
+  /* remove the event handler of the server */
+  if (e->receive_cb) ecore_event_handler_del (e->receive_cb);
   /* free node */
   if (e->root) egxp_node_free(e->root);
   /* free protocol handler */
   if (e->protocol_handler) egxp_protocol_handler_free (e->protocol_handler);
+  /* free connection */
+  if (e->connection) egxp_connection_free (e->connection);
   /* free extension */
   if (e->extensions) ecore_hash_destroy (e->extensions);
-  
   free (e);
 }
 
@@ -87,6 +100,9 @@
     ecore_hash_set_free_value (e->extensions, egxp_extension_free);
   }
   
+  /* define the parent */
+  EGXP_EXTENSION (ext)->parent = e;
+  /* add the extension to the hash */
   ecore_hash_set (e->extensions, (int*)id, ext);
 }
 

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/egxp/egxp.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -23,6 +23,7 @@
 #define egxp_header_h_
 
 #include <Ecore_Data.h>
+#include <Ecore.h>
 
 #include "egxp_node_struct.h"
 #include "egxp_node.h"
@@ -30,8 +31,8 @@
 #include "egxp_condition.h"
 #include "egxp_message.h"
 #include "egxp_protocol_handler.h"
+#include "egxp_connection.h"
 
-
 typedef struct _Egxp Egxp;
 #define EGXP(o) ((Egxp*)o)
 struct _Egxp {
@@ -44,18 +45,29 @@
   /* the protocol handler */
   Egxp_ProtocolHandler * protocol_handler;
 
+  /* The connection object */
+  Egxp_Connection * connection;
+  
   /* contains data */
   Ecore_Hash * extensions;
 
   /* specific user data */
   void * user_data;
+
+  /* Event handler of ecore server 
+     maybe it's not necessary to store it
+  */
+  Ecore_Event_Handler * receive_cb;
 };
 
 
 typedef struct _Egxp_Extension Egxp_Extension;
 #define EGXP_EXTENSION(o) ((Egxp_Extension*)o)
 struct _Egxp_Extension {
+  /* this call back is used to destroy this structure itself. */
   Ecore_Free_Cb destroy;
+  /* a pointer to the egxp structure */
+  Egxp * parent;
 };
 
 

Added: src/egxp/egxp_connection.c
===================================================================
--- src/egxp/egxp_connection.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/egxp/egxp_connection.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,116 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+
+#include "egxp_connection.h"
+
+Egxp_Connection * egxp_connection_new (char * address, unsigned int port, unsigned char use_ssl) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_connection_new\n");
+#endif
+  assert (address);
+  
+  Egxp_Connection * tmp = EGXP_CONNECTION (malloc (sizeof(Egxp_Connection)));
+ 
+  tmp->server = NULL;
+  tmp->host_addr = strdup (address);
+  tmp->use_ssl = use_ssl;
+  tmp->port = port;
+  
+  return tmp;
+}
+
+
+void egxp_connection_free (Egxp_Connection *c) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_connection_free\n");
+#endif 
+  assert (c);
+  /* free the addr */
+  IF_FREE (c->host_addr);
+  /* disconnect from the server */
+  egxp_connection_disconnect (c);
+  /* free this object */
+  FREE (c);
+}
+
+unsigned int egxp_connection_connect (Egxp_Connection *c) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_connection_connect\n");
+#endif
+  assert (c);
+
+  /* call disconnect to be sure that we are currently connected */
+  if (c->server) egxp_connection_disconnect (c);
+  
+  /* set the connection flags */
+  int flags = ECORE_CON_REMOTE_SYSTEM;
+  if (c->use_ssl) flags = flags | ECORE_CON_USE_SSL;
+ 
+  /* try to connect */
+  c->server = ecore_con_server_connect(flags, c->host_addr,
+				       c->port, NULL);
+  /* test if the connection is ok*/
+  if (c->server == NULL) return 0;
+  
+  /* on success */
+  return 1;
+}
+
+
+void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_connection_send_message\n");
+#endif
+  assert (c && msg);
+
+  // to xml
+  char * buf = egxp_message_to_xml (msg, 1);
+  printf("log send: %s\n", buf);
+  
+  // free message
+  egxp_message_free (msg);
+  
+  // send it !
+  ecore_con_server_send (c->server, buf, strlen (buf));
+  
+  // free message
+  FREE (buf);
+}
+
+
+void egxp_connection_disconnect (Egxp_Connection * c) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_connection_disconnect\n");
+#endif
+
+  assert (c);
+
+  if (c->server) {
+    /* warning FIXME, i don't how close connection work ... */
+    printf("egxp_connection_disconnect:: FIXME %s\n", __FILE__);
+    // ecore_con_server_del (c->server);
+    c->server = NULL;
+  }
+}

Added: src/egxp/egxp_connection.h
===================================================================
--- src/egxp/egxp_connection.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/egxp/egxp_connection.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,88 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef egxp_connection_header_h_
+#define egxp_connection_header_h_
+
+#include <Ecore_Con.h>
+
+#include "egxp_message.h"
+
+/**
+ * There is a set of function to handle connection properties
+ */
+typedef struct _Egxp_Connection Egxp_Connection;
+#define EGXP_CONNECTION(o) ((Egxp_Connection*)o)
+struct _Egxp_Connection {
+  
+  /* a reference on the server */
+  Ecore_Con_Server * server;
+  
+  /* address to the host */
+  char * host_addr;
+
+  /* a flag to know if we use ssl connection */
+  unsigned char use_ssl;
+  
+  /* the port to connect */
+  unsigned int port;
+};
+
+
+/**
+ * This method allocate a Egxp_Connection structure
+ * @param address: The address use to connect
+ * @param port: the port number
+ * @param use_ssl: 1 if you want to connect in ssl mode, 0 otherwise.
+ * @return Egxp_Connection structure.
+ */
+Egxp_Connection * egxp_connection_new (char * address, unsigned int port, unsigned char use_ssl);
+
+
+
+/**
+ * Free the Egxp_Connection structure.
+ * @param c: The connection object
+ */
+void egxp_connection_free (Egxp_Connection *c);
+
+/**
+ * This method try to connection to the server.
+ * @param c: The connection structure
+ * @return 1 when success, 0 otherwise
+ */
+unsigned int egxp_connection_connect (Egxp_Connection *c);
+
+
+/**
+ * This method try to send a message. It destroy the message
+ * object after send it.
+ * @param c: The connection object
+ * @param msg: The message
+ */
+void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg);
+
+
+/**
+ * Disconnect the server
+ */
+void egxp_connection_disconnect (Egxp_Connection * c);
+
+#endif

Modified: src/xmpp/Makefile.am
===================================================================
--- src/xmpp/Makefile.am	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/Makefile.am	2005-02-13 16:40:57 UTC (rev 12)
@@ -15,11 +15,15 @@
 	xmpp_opcode.h    \
 	xmpp_callback.h  \
 	xmpp_struct.h    \
-	xmpp.h
+	xmpp.h           \
+	xmpp_jid.h       \
+	xmpp_message.h
 
 libxmpp_la_SOURCES = \
 	xmpp_opcode.c    \
 	xmpp_callback.c  \
-	xmpp.c
+	xmpp.c           \
+	xmpp_jid.c       \
+	xmpp_message.c
 
 libxmpp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE) -I$(top_srcdir)/src

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/test.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,20 +1,59 @@
 #include <stdio.h>
+#include <stdlib.h>
 
+#include <Ecore.h>
+
 #include "egxp/egxp.h"
 #include "xmpp.h"
 
+
+int timer_cb (void * user_data) {
+  ecore_main_loop_quit ();
+}
+
 int main (int argc, char ** argv) {
   
-  /* create the protocol grammar */
+  /**
+   * usage
+   */
+  if (argc != 5) {
+    printf("usage:\n\t%s <name> <host_addr> <port_number> <password>\n",argv[0]);
+    return 1;
+  }
+
+  /* create Egxp  */
   Egxp * eg = egxp_new ();
   
-  /* init opcode */
-  xmpp_register (eg);
+  /* initialize protocol */
+  Xmpp * xm = xmpp_register (eg);
+  
+  
+  /* initialize ecore connection */
+  ecore_con_init();
+  /* after 3 second we quit the ecore loop */
+  ecore_timer_add (8, timer_cb, NULL);
+  printf("Quit automaticly (after 8 seconds)\n");
+  
+  /* define the connection */
+  eg->connection = egxp_connection_new (argv[2], atoi (argv[3]), 0);
+  if (egxp_connection_connect (eg->connection) == 0) {
+    printf("Impossible to connect to %s %s\n", argv[2], argv[3]);
+  } else {
+    printf("We are connected to %s:%s\n", argv[2], argv[3]);
+  }
+  
+  /* define the jid */
+  xm->jid = xmpp_jid_new (argv[1], argv[2], "eim");
+  
+  /* now we can send a message to the server */
+  
 
-  /* display opcode */
-  egxp_opcode_display (eg->opcodes);
+  /* ecore loop */
+  ecore_main_loop_begin();
+  /* shutdown */
+  ecore_con_shutdown();
   
-  /* free opcode */
+  /* free Egxp */
   egxp_free (eg);
   
   return 0;

Modified: src/xmpp/xmpp.c
===================================================================
--- src/xmpp/xmpp.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <stdio.h>
 #include <assert.h>
 #include "xmpp.h"
@@ -3,5 +23,5 @@
 
 
-void xmpp_register (Egxp * eg) {
+Xmpp * xmpp_register (Egxp * eg) {
 #ifdef XMPP_DEBUG
   printf("TRACE: xmpp_register\n");
@@ -17,6 +37,8 @@
   Xmpp * tmp = xmpp_new (eg);
   /* register the structure */
   egxp_extension_register (eg, id, tmp);
+  
+  return tmp;
 }
 
 
@@ -33,7 +55,10 @@
   
   /* define the destroy function */
   tmp->extension.destroy = ECORE_FREE_CB(xmpp_free);
-  
+
+  /* set the user name */
+  tmp->jid = NULL;
+
   /* return the xmpp */
   return tmp;
 }
@@ -45,6 +70,8 @@
 #endif
   
   assert (x);
+
+  if (x->jid) xmpp_jid_free(x->jid);
   
   FREE (x);
 }

Modified: src/xmpp/xmpp.h
===================================================================
--- src/xmpp/xmpp.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef xmpp_header_h_
 #define xmpp_header_h_
 
@@ -6,8 +26,8 @@
 #include "xmpp_struct.h"
 #include "xmpp_opcode.h"
 #include "xmpp_callback.h"
+#include "xmpp_jid.h"
 
-
 #define XMPP_REGISTER "__XMPP_REGISTER__"
 
 /**
@@ -15,8 +35,9 @@
  *  - initialize the xmpp structure
  *  - register opcode and protocol node
  * @param eg: The Egpx structure
+ * @return the Xmpp object
  */
-void xmpp_register (Egxp * eg);
+Xmpp * xmpp_register (Egxp * eg);
 
 
 /**
@@ -30,4 +51,11 @@
  */
 void xmpp_free (Xmpp * x);
 
+
+/**
+ * Set the user name
+ * @param x: The xmpp object
+ * @param name: The name of the user
+ */
+
 #endif

Modified: src/xmpp/xmpp_callback.c
===================================================================
--- src/xmpp/xmpp_callback.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_callback.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,25 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <assert.h>
+
 #include "xmpp_callback.h"
 
 

Modified: src/xmpp/xmpp_callback.h
===================================================================
--- src/xmpp/xmpp_callback.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_callback.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef xmpp_opcode_header_h_
 #define xmpp_opcode_header_h_
 

Added: src/xmpp/xmpp_jid.c
===================================================================
--- src/xmpp/xmpp_jid.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_jid.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,55 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <Ecore_Data.h>
+
+#include "xmpp_jid.h"
+
+
+Xmpp_JID * xmpp_jid_new (char * user, char * host, char * resource) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_jid_new\n");
+#endif 
+  
+  Xmpp_JID * tmp = XMPP_JID(malloc (sizeof(Xmpp_JID)));
+  
+  tmp->user = strdup (user);
+  tmp->host = strdup (host);
+  tmp->resource = strdup (resource);
+
+  return tmp;
+}
+
+void xmpp_jid_free (Xmpp_JID * jid) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_jid_free\n");
+#endif 
+  assert (jid);
+
+  IF_FREE (jid->user);
+  IF_FREE (jid->host);
+  IF_FREE (jid->resource);
+
+  FREE (jid);
+}

Added: src/xmpp/xmpp_jid.h
===================================================================
--- src/xmpp/xmpp_jid.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_jid.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,52 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef xmpp_jid_header_h_
+#define xmpp_jid_header_h_
+
+/**
+ * Here we define the Jid structure and a set of function
+ * to handle the jid
+ */
+
+typedef struct _Xmpp_JID Xmpp_JID;
+#define XMPP_JID(o) ((Xmpp_JID*)o)
+struct _Xmpp_JID {
+  char * user;
+  char * host;
+  char * resource;
+};
+
+
+/**
+ * Create a new JID
+ * @param user: The user name
+ * @param host: The host name
+ * @param resource: The resource
+ */
+Xmpp_JID * xmpp_jid_new (char * user, char * host, char * resource);
+
+/**
+ * Free the structure
+ */
+void xmpp_jid_free (Xmpp_JID * jid);
+
+
+#endif

Added: src/xmpp/xmpp_message.c
===================================================================
--- src/xmpp/xmpp_message.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_message.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,65 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <assert.h>
+#include <stdlib.h>
+
+#include "egxp/egxp_message.h"
+
+#include "xmpp_opcode.h"
+#include "xmpp_message.h"
+
+
+
+int xmpp_message_stream (Xmpp * x) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_message_stream\n");
+#endif
+  
+  assert (x);
+
+  /**
+   * Make the stream message
+   */
+  Egxp_Message * message = egxp_message_new (XMPP_TAG_STREAM);
+  egxp_message_add_attribute (message, 
+			      egxp_message_attribute_new (XMPP_ATT_XMLNS, 
+							  XMPP_VALUE_STREAM_XMLNS));
+  egxp_message_add_attribute (message, 
+			      egxp_message_attribute_new (XMPP_ATT_XMLNS_STREAM, 
+							  XMPP_VALUE_STREAM_XMLNS_STREAM));
+  egxp_message_add_attribute (message, 
+			      egxp_message_attribute_new (XMPP_ATT_VERSION, 
+							  XMPP_VALUE_STREAM_VERSION));
+  egxp_message_add_attribute (message, 
+			      egxp_message_attribute_new (XMPP_ATT_TO, 
+							  x->jid->host));
+  
+  /* to xml */
+  char * buf = egxp_message_to_xml (message, 0);
+  
+  /* free message */
+  egxp_message_free (message);
+
+  // to be continued ...
+  
+  /* free buffer */
+  FREE(buf);
+}

Added: src/xmpp/xmpp_message.h
===================================================================
--- src/xmpp/xmpp_message.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_message.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -0,0 +1,33 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#ifndef xmpp_message_header_h_
+#define xmpp_message_header_h_
+
+#include "xmpp_struct.h"
+
+/**
+ * It defines the messages send to the server.
+ * @param x: The Xmpp structure
+ */
+int xmpp_message_stream (Xmpp * x);
+
+
+#endif

Modified: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_opcode.c	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #include <assert.h>
 
 #include "egxp/egxp_node.h"
@@ -2,2 +22,3 @@
 
+#include "xmpp_callback.h"
 #include "xmpp_opcode.h"
@@ -40,4 +61,6 @@
   egxp_node_add_condition (stream, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_XMLNS_STREAM),
 						       egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_STREAM_XMLNS_STREAM)));
   
+  egxp_node_set_cb (stream, xmpp_callback_stream_begin_cb, NULL);
+  
 }

Modified: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_opcode.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef xmpp_core_header_h_
 #define xmpp_core_header_h_
 

Modified: src/xmpp/xmpp_struct.h
===================================================================
--- src/xmpp/xmpp_struct.h	2005-02-13 01:13:42 UTC (rev 11)
+++ src/xmpp/xmpp_struct.h	2005-02-13 16:40:57 UTC (rev 12)
@@ -1,3 +1,23 @@
+/*
+   $Id$
+
+   Copyright (C) 2005 Jo?l Vennin < joel.vennin _ at _ gmail _dot_ com >
+   Part of the Eim Project http://eim.berlios.de
+
+   Eim is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   Eim is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Eim; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 #ifndef xmpp_struct_header_h_
 #define xmpp_struct_header_h_
 
@@ -5,13 +25,16 @@
 
 #include "egxp/egxp.h"
 
+#include "xmpp_jid.h"
+
 typedef struct _Xmpp Xmpp;
 #define XMPP(o) ((Xmpp*)o)
 struct _Xmpp {
   /* This variable is really important, it's used to destroy itself */
   Egxp_Extension extension;
   
-  int t;
+  /* the jid */
+  Xmpp_JID * jid;
 };
 
 #endif



From jol at sheep.berlios.de  Tue Feb 15 22:37:33 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Tue, 15 Feb 2005 22:37:33 +0100
Subject: [Eim-svn] r13 - / src/egxp src/xmpp
Message-ID: <200502152137.j1FLbXcY005543@sheep.berlios.de>

Author: jol
Date: 2005-02-15 22:37:32 +0100 (Tue, 15 Feb 2005)
New Revision: 13

Added:
   src/xmpp/xmpp_auth.c
   src/xmpp/xmpp_auth.h
Modified:
   ChangeLog
   src/egxp/egxp.c
   src/egxp/egxp.h
   src/egxp/egxp_connection.c
   src/egxp/egxp_connection.h
   src/xmpp/Makefile.am
   src/xmpp/test.c
   src/xmpp/xmpp.c
   src/xmpp/xmpp.h
   src/xmpp/xmpp_callback.c
   src/xmpp/xmpp_callback.h
   src/xmpp/xmpp_message.c
   src/xmpp/xmpp_message.h
   src/xmpp/xmpp_opcode.h
   src/xmpp/xmpp_struct.h
Log:
- now it's possible to connect to a server
- add the xmpp_auth file which should handle authentification process
- The first step of authentification is done


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-13 16:40:57 UTC (rev 12)
+++ ChangeLog	2005-02-15 21:37:32 UTC (rev 13)
@@ -1,3 +1,8 @@
+2005-02-15(jol):
+	- now it's possible to connect to a server
+	- add the xmpp_auth file which should handle authentification process
+	- The first step of authentification is done
+	
 2005-02-13(jol):
 	- Add connection control inside egxp. So it's now possible to connect/disconnect 
 	  and get/send message to a server.
@@ -41,4 +46,3 @@
 	- fix a memleak from egxp_free
 	- add Egxp_ConditionalNode
 	- add TODO file
-	

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/egxp/egxp.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -116,3 +116,13 @@
 
   return ecore_hash_get (e->extensions, (int*)id);
 }
+
+void * egxp_extension_get_from_string (Egxp *e, char * id) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_extension_get_from_string\n");
+#endif
+  assert (e && id);
+  assert (e->extensions);
+
+  return egxp_extension_get (e, egxp_opcode_get_id (e->opcodes, id));
+}

Modified: src/egxp/egxp.h
===================================================================
--- src/egxp/egxp.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/egxp/egxp.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -97,4 +97,9 @@
  */
 void * egxp_extension_get (Egxp *e, int id);
 
+
+/**
+ * @return the extension
+ */
+void * egxp_extension_get_from_string (Egxp *e, char * id);
 #endif

Modified: src/egxp/egxp_connection.c
===================================================================
--- src/egxp/egxp_connection.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/egxp/egxp_connection.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -57,7 +57,7 @@
 
 unsigned int egxp_connection_connect (Egxp_Connection *c) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_connection_connect\n");
+  printf("TRACE: egxp_connection_connect: %s:%d\n", c->host_addr, c->port);
 #endif
   assert (c);
 
@@ -79,15 +79,15 @@
 }
 
 
-void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg) {
+void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg, unsigned int end_tag) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_connection_send_message\n");
 #endif
   assert (c && msg);
 
   // to xml
-  char * buf = egxp_message_to_xml (msg, 1);
-  printf("log send: %s\n", buf);
+  char * buf = egxp_message_to_xml (msg, end_tag);
+  printf("log send: %s\nsize: %d\n", buf, strlen (buf));
   
   // free message
   egxp_message_free (msg);

Modified: src/egxp/egxp_connection.h
===================================================================
--- src/egxp/egxp_connection.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/egxp/egxp_connection.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -76,8 +76,9 @@
  * object after send it.
  * @param c: The connection object
  * @param msg: The message
+ * @param end_tag: if set to 1 we send the last </tag> of the message, if it's equals to zero it not send the last tag ... 
  */
-void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg);
+void egxp_connection_send_message (Egxp_Connection *c, Egxp_Message * msg, unsigned int end_tag);
 
 
 /**

Modified: src/xmpp/Makefile.am
===================================================================
--- src/xmpp/Makefile.am	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/Makefile.am	2005-02-15 21:37:32 UTC (rev 13)
@@ -17,13 +17,15 @@
 	xmpp_struct.h    \
 	xmpp.h           \
 	xmpp_jid.h       \
-	xmpp_message.h
+	xmpp_message.h   \
+	xmpp_auth.h
 
 libxmpp_la_SOURCES = \
 	xmpp_opcode.c    \
 	xmpp_callback.c  \
 	xmpp.c           \
 	xmpp_jid.c       \
-	xmpp_message.c
+	xmpp_message.c   \
+	xmpp_auth.c
 
 libxmpp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE) -I$(top_srcdir)/src

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/test.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -21,22 +21,22 @@
     return 1;
   }
 
+  /* initialize ecore connection */
+  ecore_con_init();
+
   /* create Egxp  */
   Egxp * eg = egxp_new ();
   
   /* initialize protocol */
   Xmpp * xm = xmpp_register (eg);
   
-  
-  /* initialize ecore connection */
-  ecore_con_init();
   /* after 3 second we quit the ecore loop */
-  ecore_timer_add (8, timer_cb, NULL);
-  printf("Quit automaticly (after 8 seconds)\n");
+  ecore_timer_add (5, timer_cb, NULL);
+  printf("Quit automaticly (after 5 seconds)\n");
   
   /* define the connection */
   eg->connection = egxp_connection_new (argv[2], atoi (argv[3]), 0);
-  if (egxp_connection_connect (eg->connection) == 0) {
+  if (egxp_connection_connect (eg->connection) == 0) { 
     printf("Impossible to connect to %s %s\n", argv[2], argv[3]);
   } else {
     printf("We are connected to %s:%s\n", argv[2], argv[3]);
@@ -46,8 +46,8 @@
   xm->jid = xmpp_jid_new (argv[1], argv[2], "eim");
   
   /* now we can send a message to the server */
+  xmpp_message_stream (xm);
   
-
   /* ecore loop */
   ecore_main_loop_begin();
   /* shutdown */

Modified: src/xmpp/xmpp.c
===================================================================
--- src/xmpp/xmpp.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -59,6 +59,9 @@
   /* set the user name */
   tmp->jid = NULL;
 
+  /* initialize authentification */
+  tmp->auth = NULL;
+
   /* return the xmpp */
   return tmp;
 }
@@ -72,6 +75,6 @@
   assert (x);
 
   if (x->jid) xmpp_jid_free(x->jid);
-  
+  if (x->auth) xmpp_auth_free(x->auth);
   FREE (x);
 }

Modified: src/xmpp/xmpp.h
===================================================================
--- src/xmpp/xmpp.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -27,6 +27,8 @@
 #include "xmpp_opcode.h"
 #include "xmpp_callback.h"
 #include "xmpp_jid.h"
+#include "xmpp_auth.h"
+#include "xmpp_message.h"
 
 #define XMPP_REGISTER "__XMPP_REGISTER__"
 

Added: src/xmpp/xmpp_auth.c
===================================================================
--- src/xmpp/xmpp_auth.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_auth.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -0,0 +1,58 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <Ecore_Data.h>
+#include "xmpp.h"
+
+#include "xmpp_auth.h"
+
+Xmpp_Auth * xmpp_auth_new () {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_auth_new\n");
+#endif
+
+  Xmpp_Auth * auth = XMPP_AUTH(malloc (sizeof(Xmpp_Auth)));
+  
+  auth->password = NULL;
+  auth->stream_id = NULL;
+  
+  return auth;
+}
+
+
+void xmpp_auth_free (Xmpp_Auth * a) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_auth_free\n");
+#endif
+  assert (a);
+  
+  IF_FREE(a->password);
+  IF_FREE(a->stream_id);
+  FREE(a);
+}
+
+
+void xmpp_auth_msg_no_sasl (Xmpp * x) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_auth_msg_no_sasl\n");
+#endif
+  assert (x);
+ 
+  /* create the iq type="get" */
+  Egxp_Message * iq = xmpp_message_iq (XMPP_VALUE_IQ_GET, "auth_1", 
+				       x->jid->host);
+  /* create the query message */
+  Egxp_Message * query = xmpp_message_query (XMPP_VALUE_QUERY_AUTH);
+  /* create the username node */
+  Egxp_Message * username = egxp_message_new (XMPP_TAG_USERNAME);
+  egxp_message_append_data (username, x->jid->user, strlen (x->jid->user));
+  
+  /* compose */
+  egxp_message_add_child (iq, query);
+  egxp_message_add_child (query, username);
+
+  /* now send it */
+  Egxp_Connection * conn = EGXP_EXTENSION(x)->parent->connection;
+  egxp_connection_send_message (conn, iq, 1);
+}

Added: src/xmpp/xmpp_auth.h
===================================================================
--- src/xmpp/xmpp_auth.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_auth.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -0,0 +1,43 @@
+#ifndef xmpp_auth_header_h_
+#define xmpp_auth_header_h_
+
+struct _Xmpp;
+
+/**
+ * This structure and set of functions should 
+ * manage the authentification step of the jabber protocol.
+ */
+typedef struct _Xmpp_Auth Xmpp_Auth;
+#define XMPP_AUTH(o) ((Xmpp_Auth*)o)
+struct _Xmpp_Auth {
+  
+  /* store the password */
+  char * password;
+
+  /* store the stream id */
+  char * stream_id;
+};
+
+
+/**
+ * Initialize the structure
+ */
+Xmpp_Auth * xmpp_auth_new ();
+
+
+/**
+ * Free the authentification structure
+ * - free the password
+ * - free the stream id
+ */
+void xmpp_auth_free (Xmpp_Auth * a);
+
+
+
+/**
+ * Send a message to try to be authenticiate in
+ * no SASL mode
+ */
+void xmpp_auth_msg_no_sasl (struct _Xmpp * x);
+
+#endif

Modified: src/xmpp/xmpp_callback.c
===================================================================
--- src/xmpp/xmpp_callback.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_callback.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -20,6 +20,8 @@
 */
 #include <assert.h>
 
+#include "egxp/egxp.h"
+#include "xmpp.h"
 #include "xmpp_callback.h"
 
 
@@ -29,5 +31,19 @@
 #endif 
   assert (msg && eg);
   
+  /* get the xmpp protocol */
+  Xmpp * xm = XMPP( egxp_extension_get_from_string (EGXP(eg), XMPP_REGISTER));
+  assert (xm);
+
+  /* technically we should control childs of stream tag. But for
+     now we just try to authenticate our client NO-SASL */
   
+  /* check if there is a authentification object */
+  if (xm->auth == NULL) xm->auth = xmpp_auth_new ();
+
+  /* try to set the stream id */
+  xm->auth->stream_id = egxp_message_get_attribute (msg, XMPP_ATT_ID);
+  
+  /* now we can try to send the first message to be authenticied */
+  xmpp_auth_msg_no_sasl (xm);
 }

Modified: src/xmpp/xmpp_callback.h
===================================================================
--- src/xmpp/xmpp_callback.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_callback.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -25,7 +25,9 @@
 
 
 /**
- * Stream begin callback
+ * Stream begin callback.
+ *  - try to get the stream id.
+ *  - send a message to authenticiate.
  */
 void xmpp_callback_stream_begin_cb (Egxp_Message * msg, void * eg);
 

Modified: src/xmpp/xmpp_message.c
===================================================================
--- src/xmpp/xmpp_message.c	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_message.c	2005-02-15 21:37:32 UTC (rev 13)
@@ -34,7 +34,7 @@
 #endif
   
   assert (x);
-
+  
   /**
    * Make the stream message
    */
@@ -52,14 +52,38 @@
 			      egxp_message_attribute_new (XMPP_ATT_TO, 
 							  x->jid->host));
   
-  /* to xml */
-  char * buf = egxp_message_to_xml (message, 0);
-  
-  /* free message */
-  egxp_message_free (message);
+  /* send message */
+  /* get reference to the connection */
+  Egxp_Connection * conn = EGXP_EXTENSION(x)->parent->connection;
+  egxp_connection_send_message (conn, message, 0);
+}
 
-  // to be continued ...
+Egxp_Message * xmpp_message_iq (char * type, char * id, char * to) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_message_iq\n");
+#endif
+  assert (type && id);
   
-  /* free buffer */
-  FREE(buf);
+  /* create the iq */
+  Egxp_Message * msg = egxp_message_new (XMPP_TAG_IQ);
+  egxp_message_add_attribute (msg, egxp_message_attribute_new (XMPP_ATT_TYPE,
+							       type));
+  /* id */
+  egxp_message_add_attribute (msg, egxp_message_attribute_new (XMPP_ATT_ID,
+							       id));
+  /* to */
+  if (to) 
+    egxp_message_add_attribute (msg, egxp_message_attribute_new (XMPP_ATT_TO,
+								 to));
+  
+  return msg;
 }
+
+
+Egxp_Message * xmpp_message_query (char * xmlns) {
+  Egxp_Message * message = egxp_message_new (XMPP_TAG_QUERY);
+  egxp_message_add_attribute (message, 
+			      egxp_message_attribute_new (XMPP_ATT_XMLNS, 
+							  xmlns));
+  return message;
+}

Modified: src/xmpp/xmpp_message.h
===================================================================
--- src/xmpp/xmpp_message.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_message.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -21,6 +21,7 @@
 #ifndef xmpp_message_header_h_
 #define xmpp_message_header_h_
 
+#include "egxp/egxp_message.h"
 #include "xmpp_struct.h"
 
 /**
@@ -30,4 +31,23 @@
 int xmpp_message_stream (Xmpp * x);
 
 
+/**
+ * This function is an helper function to 
+ * build preconfigured iq message.
+ * @param type: "set" or "get" must not be null
+ * @param id: "id of the query" must not be null
+ * @param to: "the destination"
+ * @return the build message
+ */
+Egxp_Message * xmpp_message_iq (char * type, char * id, char * to);
+
+
+/**
+ * This function is a helper function to build a preconfigured
+ * query message.
+ * @param xmlns: The xmlns value
+ * @return the query build message
+ */
+Egxp_Message * xmpp_message_query (char * xmlns);
+
 #endif

Modified: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_opcode.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -27,7 +27,11 @@
  * Here we define the xmpp opcodes
  */
 #define XMPP_TAG_STREAM "stream:stream"
+#define XMPP_TAG_IQ     "iq"
+#define XMPP_TAG_QUERY  "query"
 
+#define XMPP_TAG_USERNAME       "username"
+
 #define XMPP_ATT_XMLNS          "xmlns"
 #define XMPP_ATT_XMLNS_STREAM   "xmlns:stream"
 
@@ -46,9 +50,11 @@
 #define XMPP_ATT_FROM           "from"
 #define XMPP_ATT_NAME           "name"
 
+#define XMPP_VALUE_IQ_GET       "get"
+#define XMPP_VALUE_IQ_SET       "set"
 
+#define XMPP_VALUE_QUERY_AUTH   "jabber:iq:auth"
 
-
 /**
  * Add the xmpp opcode inside the opcode variable
  * @param opcode: use to store xmpp opcode

Modified: src/xmpp/xmpp_struct.h
===================================================================
--- src/xmpp/xmpp_struct.h	2005-02-13 16:40:57 UTC (rev 12)
+++ src/xmpp/xmpp_struct.h	2005-02-15 21:37:32 UTC (rev 13)
@@ -26,6 +26,7 @@
 #include "egxp/egxp.h"
 
 #include "xmpp_jid.h"
+#include "xmpp_auth.h"
 
 typedef struct _Xmpp Xmpp;
 #define XMPP(o) ((Xmpp*)o)
@@ -35,6 +36,9 @@
   
   /* the jid */
   Xmpp_JID * jid;
+
+  /* the authentification structure */
+  Xmpp_Auth * auth;
 };
 
 #endif



From jol at sheep.berlios.de  Tue Feb 15 22:49:20 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Tue, 15 Feb 2005 22:49:20 +0100
Subject: [Eim-svn] r14 - / doc src src/egxp src/xmpp
Message-ID: <200502152149.j1FLnK9L006051@sheep.berlios.de>

Author: jol
Date: 2005-02-15 22:49:19 +0100 (Tue, 15 Feb 2005)
New Revision: 14

Modified:
   /
   doc/
   src/
   src/egxp/
   src/xmpp/
Log:
Ignoring ignorable files


Property changes on: 
___________________________________________________________________
Name: svn:ignore
   + configure
Makefile.in
config.log
depcomp
compile
config.guess
config.h
ltmain.sh
config.sub
Makefile
config.status
stamp-h1
config.h.in
libtool
autom4te.cache
missing
aclocal.m4
install-sh



Property changes on: doc
___________________________________________________________________
Name: svn:ignore
   + Makefile.in
Makefile



Property changes on: src
___________________________________________________________________
Name: svn:ignore
   + Makefile.in
Makefile



Property changes on: src/egxp
___________________________________________________________________
Name: svn:ignore
   + Makefile.in
Makefile
.libs
.deps
test



Property changes on: src/xmpp
___________________________________________________________________
Name: svn:ignore
   + Makefile.in
Makefile
.libs
.deps
test




From jol at sheep.berlios.de  Tue Feb 15 22:57:24 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Tue, 15 Feb 2005 22:57:24 +0100
Subject: [Eim-svn] r15 - in src: egxp xmpp
Message-ID: <200502152157.j1FLvOU6006311@sheep.berlios.de>

Author: jol
Date: 2005-02-15 22:57:22 +0100 (Tue, 15 Feb 2005)
New Revision: 15

Modified:
   src/egxp/egxp.c
   src/egxp/egxp.h
   src/egxp/egxp_condition.c
   src/egxp/egxp_condition.h
   src/egxp/egxp_connection.c
   src/egxp/egxp_connection.h
   src/egxp/egxp_message.c
   src/egxp/egxp_message.h
   src/egxp/egxp_node.c
   src/egxp/egxp_node.h
   src/egxp/egxp_node_struct.h
   src/egxp/egxp_opcode.c
   src/egxp/egxp_opcode.h
   src/egxp/egxp_protocol_handler.c
   src/egxp/egxp_protocol_handler.h
   src/egxp/test.c
   src/xmpp/test.c
   src/xmpp/xmpp.c
   src/xmpp/xmpp.h
   src/xmpp/xmpp_auth.c
   src/xmpp/xmpp_auth.h
   src/xmpp/xmpp_callback.c
   src/xmpp/xmpp_callback.h
   src/xmpp/xmpp_jid.c
   src/xmpp/xmpp_jid.h
   src/xmpp/xmpp_message.c
   src/xmpp/xmpp_message.h
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
   src/xmpp/xmpp_struct.h
Log:
imported svn:keywords properties




Property changes on: src/egxp/egxp.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_condition.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_condition.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_connection.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_connection.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_message.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_message.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_node.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_node.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_node_struct.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_opcode.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_opcode.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_protocol_handler.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/egxp_protocol_handler.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/egxp/test.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/test.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_auth.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_auth.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_callback.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_callback.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_jid.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_jid.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_message.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_message.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_opcode.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_opcode.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xmpp/xmpp_struct.h
___________________________________________________________________
Name: svn:keywords
   + Id



From jol at sheep.berlios.de  Thu Feb 17 23:52:15 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Thu, 17 Feb 2005 23:52:15 +0100
Subject: [Eim-svn] r16 - / src/egxp src/xmpp
Message-ID: <200502172252.j1HMqFc0028630@sheep.berlios.de>

Author: jol
Date: 2005-02-17 23:52:14 +0100 (Thu, 17 Feb 2005)
New Revision: 16

Modified:
   ChangeLog
   src/egxp/egxp.c
   src/egxp/egxp_condition.c
   src/egxp/egxp_message.c
   src/egxp/egxp_opcode.c
   src/egxp/egxp_protocol_handler.c
   src/egxp/test.c
   src/xmpp/test.c
   src/xmpp/xmpp_auth.c
   src/xmpp/xmpp_jid.c
   src/xmpp/xmpp_message.c
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
Log:
- try to fix some memory leaks
- minor changes


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-15 21:57:22 UTC (rev 15)
+++ ChangeLog	2005-02-17 22:52:14 UTC (rev 16)
@@ -1,3 +1,6 @@
+2005-02-18(jol):
+	- Try to fix some memory leaks
+	
 2005-02-15(jol):
 	- now it's possible to connect to a server
 	- add the xmpp_auth file which should handle authentification process

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/egxp.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -84,7 +84,8 @@
   printf("TRACE: egxp_extension_free\n");
 #endif
   assert (e);
-  
+
+  /* call the destroy function of the register */
   Egxp_Extension * ext = EGXP_EXTENSION(e);
   ext->destroy (e);
 }

Modified: src/egxp/egxp_condition.c
===================================================================
--- src/egxp/egxp_condition.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/egxp_condition.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -20,6 +20,8 @@
 */
 #include <assert.h>
 #include <stdio.h>
+#include <stdlib.h>
+#include <Ecore_Data.h>
 
 #include "egxp_condition.h"
 
@@ -40,7 +42,7 @@
 
   assert (condition != NULL);
   
-  free (condition);
+  FREE (condition);
 }
 
 

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/egxp_message.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -19,6 +19,7 @@
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
 
+#include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
@@ -32,6 +33,10 @@
 /*****************************************************************************/
 
 Egxp_Message * egxp_message_new (char * tag_name) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_new\n");
+#endif
+  
   Egxp_Message * tmp = (Egxp_Message*) malloc (sizeof (Egxp_Message));
   
   /* copy the tag name */
@@ -54,21 +59,29 @@
 
 
 void egxp_message_free (Egxp_Message * m) {
-  if (m == NULL) return;
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_free\n");
+#endif
   
+  assert (m);
+  
   FREE (m->tagname);
   ecore_list_destroy (m->attributes);
   ecore_list_destroy (m->childs);
   
   /* if attached to a parent, we remove the dependancies */
   if (m->parent) {
-    egxp_message_remove_child (m->parent, m);
+    // egxp_message_remove_child (m->parent, m);
   }
-  
+  IF_FREE (m->data);
   FREE (m);
 }
 
 Egxp_Message * egxp_message_get_child (Egxp_Message *m, char * tagname) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_get_child\n");
+#endif
+
   assert (m != NULL && tagname != NULL);
 
   ecore_list_goto_first(m->childs);
@@ -82,6 +95,10 @@
 }
 
 Ecore_List * egxp_message_get_childs (Egxp_Message *m, char * tagname) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_get_childs\n");
+#endif
+
   assert (m != NULL && tagname != NULL);
 
   Ecore_List * result = ecore_list_new ();
@@ -98,6 +115,10 @@
 
 
 void egxp_message_add_attribute (Egxp_Message *m, Egxp_MessageAttribute * ma) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_add_attribute\n");
+#endif
+  
   if (m == NULL) return;
   
   ecore_list_append (m->attributes, ma);
@@ -105,6 +126,10 @@
 
 
 char * egxp_message_get_attribute (Egxp_Message *m, char * key) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_get_attribute\n");
+#endif
+
   assert (m != NULL && key != NULL);
   
   ecore_list_goto_first(m->attributes);
@@ -117,6 +142,10 @@
 }
 
 void egxp_message_add_child (Egxp_Message *m, Egxp_Message * ma) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_add_child\n");
+#endif
+  
   if (m == NULL || ma == NULL) return;
   
   ecore_list_append (m->childs, ma);
@@ -124,6 +153,10 @@
 }
 
 void egxp_message_remove_child (Egxp_Message *m, Egxp_Message * ma) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_remove_child\n");
+#endif
+
   assert (m != NULL && ma != NULL);
 
   ecore_list_goto_first(m->childs);
@@ -138,6 +171,10 @@
 
 
 void egxp_message_append_data (Egxp_Message *m, char * data, unsigned int size) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_append_data\n");
+#endif
+
   assert (m!= NULL);
 
   // i think we can just use realloc ... but i'm not sure about strcat 
@@ -158,16 +195,27 @@
 
 
 char * egxp_message_get_data (Egxp_Message *m) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_get_data\n");
+#endif
+
   assert (m != NULL);
   
   /* if there is no data we return NULL */
   if (m->data == NULL) return NULL;
   
-  return (char*)strndup (m->data, m->data_size);
+  char * buf = (char*) malloc ((m->data_size + 1) * sizeof (char));
+  strncpy (buf, m->data, m->data_size);
+  
+  return buf;
 }
 
 
 char * egxp_message_to_xml (Egxp_Message *m, unsigned int endtag) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_to_xml\n");
+#endif
+
   int buf_len, len;
   char * buf;
 
@@ -251,6 +299,9 @@
 }
 
 void egxp_message_print(Egxp_Message *m) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_print\n");
+#endif
   if (m == NULL) return;
   char * buf = egxp_message_to_xml (m, 1);
   printf("%s\n", buf);
@@ -259,12 +310,18 @@
 
 
 unsigned int egxp_message_is_empty (Egxp_Message *m) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_is_empty\n");
+#endif
   assert (m != NULL);
   return (ecore_list_is_empty (m->childs) && m->data == NULL);
 }
 
 
 Egxp_MessageAttribute * egxp_message_attribute_new (char * key, char * value) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_attribute_new\n");
+#endif
   Egxp_MessageAttribute * tmp = (Egxp_MessageAttribute *) malloc (sizeof (Egxp_MessageAttribute));
   
   tmp->key = strdup (key);
@@ -274,6 +331,10 @@
 }
 
 void egxp_message_attribute_free (Egxp_MessageAttribute * ma) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_attribute_free\n");
+#endif
+
   if (ma == NULL) return;
   
   FREE (ma->key);

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/egxp_opcode.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -21,6 +21,7 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 
 #include "egxp_opcode.h"
 
@@ -52,11 +53,11 @@
   assert (op);
   
   /* free only the initial pointer */
-  free (op->id_string);
+  IF_FREE (op->id_string);
 
   // static string, so it's forbidden to destroy if (op->id_string) free (op->id_string);
   ecore_hash_destroy (op->string_id);
-  free (op);
+  FREE (op);
 }
 
 
@@ -71,6 +72,10 @@
   int * id = (int*) malloc (sizeof (int));
   *id = op->id++;
   
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_opcode_add -> %s %d\n", name, *id);
+#endif 
+
   /* add the new element */
   ecore_hash_set (op->string_id, (char*)name, id);
 
@@ -130,7 +135,7 @@
 
   int * tmp = ecore_hash_get (op->string_id, (char*)name);
   if (!tmp) {
-    printf("ERROR: unknown opcode %s.\n"); 
+    printf("ERROR: unknown opcode %s.\n", name); 
     return -1;
   }
   

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/egxp_protocol_handler.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -84,7 +84,7 @@
 
 void egxp_protocol_handler_start_element(void *userData, const char *name, const char **atts) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_protocol_handler_start_element\n");
+  printf("TRACE: egxp_protocol_handler_start_element : %s\n", name);
 #endif
   assert (userData && name);
   
@@ -92,7 +92,6 @@
   Egxp * eg = EGXP (userData);
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   int i;
-  char use_callback = 0;
   Egxp_Node * node = NULL;
 
   assert (eg && ph);
@@ -131,17 +130,26 @@
 
 void egxp_protocol_handler_end_element(void *userData, const char *name) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_protocol_handler_end_element\n");
+  printf("TRACE: egxp_protocol_handler_end_element : %s\n", name);
 #endif
   assert (userData && name);
-
+  
   Egxp * eg = EGXP (userData);
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   
   assert (eg && ph);
   
+  assert (ph->current_msg);
+  
+  egxp_message_print(ph->current_msg);
+  
   /* check if the current message is equal to the current protocol stack node */
   if (egxp_protocol_handler_equals (ph->protocol_stack, ph->current_msg, eg->opcodes)) {
+    
+#ifdef EGXP_DEBUG
+    printf("TRACE: egxp_protocol_handler_end_element -> matches opcode : %s\n", name);
+#endif   
+    
     /* if equals we can call the callback associated to the end and update the protocol_stack */
     if (ph->protocol_stack->end_cb != NULL) ph->protocol_stack->end_cb (ph->current_msg, eg);
     
@@ -151,10 +159,18 @@
     /* go to the parent message and destroy the current message */
     Egxp_Message * old = ph->current_msg;
     ph->current_msg = old->parent;
+    if (ph->current_msg) egxp_message_remove_child (ph->current_msg, old);
     egxp_message_free (old);
+    
   } else {
+
+#ifdef EGXP_DEBUG
+    printf("TRACE: egxp_protocol_handler_end_element -> NOT matches opcode : %s\n", name);
+#endif   
     ph->current_msg = ph->current_msg->parent;
   }
+  
+  assert (ph->current_msg);
 }
 
 
@@ -255,7 +271,7 @@
 
 
 int egxp_protocol_handler_receive_server_cb (void *data, int type, Ecore_Con_Event_Server_Data *ev) {
-#ifdef EJAB_DEBUG
+#ifdef EGXP_DEBUG
   printf("TRACE: egxp_protocol_handler_receive_server_cb\n");
 #endif
   
@@ -265,7 +281,11 @@
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   XML_Parser parser =  ph->parser;
   
-  printf("Got server data %X [%d] (%s)\n", ev->server, ev->size, (char *)ev->data);
+  char * tmp_buf = (char*) malloc ((ev->size +1) * sizeof (char));
+  tmp_buf[ev->size] = '\0';
+  strncpy (tmp_buf, (char*)ev->data, ev->size); 
+  printf("Got server data %p [%d] (%s)\n", ev->server, ev->size, tmp_buf);
+  free (tmp_buf);
   
   if (XML_Parse(parser, (char*) ev->data, ev->size, 0) == XML_STATUS_ERROR) {
     fprintf(stderr, "%s at line %d\n",

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/egxp/test.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -3,14 +3,22 @@
 
 #include "egxp.h"
 
+#define OP_1 "op1"
+#define OP_2 "op2"
 
 
+void test_opcode (Egxp_Opcode * opcodes) {
+  egxp_opcode_add (opcodes, OP_1);
+  egxp_opcode_add (opcodes, OP_2);
+}
+
+
+
 int main (int argc, char ** argv) {
   /* create the protocol grammar */
   Egxp * eg = egxp_new ();
   Egxp_Node * n1 = NULL;
   Egxp_Node * n2 = NULL;
-  Egxp_Node * n3 = NULL;
   
   /******************************************************/
   /******************************************************/
@@ -18,6 +26,7 @@
   /******************************************************/
   /******************************************************/
   
+  test_opcode (eg->opcodes);
 
   /* define basics grammar */
   egxp_opcode_add (eg->opcodes, "stream");
@@ -72,21 +81,27 @@
   /* test if it's possible to get the node from the egxp protocol handler */
   n1 = egxp_protocol_handler_get_node (eg->protocol_handler->protocol_stack,
                                        mesg1, eg->opcodes);
-  printf("Get stream node from protocol handler(it should not be null): %X\n", n1); 
+  printf("Get stream node from protocol handler(it should not be null): %p\n", n1); 
   
+  
+  eg->protocol_handler->current_msg = mesg1;
+  
   /* free the message */
-  egxp_message_free (mesg1);
+  //  egxp_message_free (mesg1);
   
   
 
   /* create a iq message with one attributes */
-  mesg1 = egxp_message_new ("iq");
-  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("type", "get"));
+  Egxp_Message * mesg2 = egxp_message_new ("iq");
+  egxp_message_add_attribute (mesg2, egxp_message_attribute_new ("type", "get"));
   /* test if it's possible to get the node from the egxp protocol handler */
-  printf("Get iq node from protocol handler(it should not be null): %X\n",
-         egxp_protocol_handler_get_node (n1, mesg1, eg->opcodes));
+  printf("Get iq node from protocol handler(it should not be null): %p\n",
+         egxp_protocol_handler_get_node (n1, mesg2, eg->opcodes));
+  
+  egxp_message_add_child (mesg1, mesg2);
+
   /* free the message */
-  egxp_message_free (mesg1);
+  // egxp_message_free (mesg1);
   
   
   /* free opcode */

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/test.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -9,6 +9,7 @@
 
 int timer_cb (void * user_data) {
   ecore_main_loop_quit ();
+  return 1;
 }
 
 int main (int argc, char ** argv) {
@@ -45,9 +46,11 @@
   /* define the jid */
   xm->jid = xmpp_jid_new (argv[1], argv[2], "eim");
   
+  egxp_opcode_display (eg->opcodes);
+
   /* now we can send a message to the server */
   xmpp_message_stream (xm);
-  
+
   /* ecore loop */
   ecore_main_loop_begin();
   /* shutdown */

Modified: src/xmpp/xmpp_auth.c
===================================================================
--- src/xmpp/xmpp_auth.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/xmpp_auth.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -12,8 +12,10 @@
   printf("TRACE: xmpp_auth_new\n");
 #endif
 
+  /* initialize the structure */
   Xmpp_Auth * auth = XMPP_AUTH(malloc (sizeof(Xmpp_Auth)));
   
+  /* initialize data */
   auth->password = NULL;
   auth->stream_id = NULL;
   
@@ -27,8 +29,11 @@
 #endif
   assert (a);
   
+  /* free password && stream_id */
   IF_FREE(a->password);
   IF_FREE(a->stream_id);
+  
+  /* free structure */
   FREE(a);
 }
 

Modified: src/xmpp/xmpp_jid.c
===================================================================
--- src/xmpp/xmpp_jid.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/xmpp_jid.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -21,6 +21,7 @@
 #include <assert.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 
 #include <Ecore_Data.h>
 

Modified: src/xmpp/xmpp_message.c
===================================================================
--- src/xmpp/xmpp_message.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/xmpp_message.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -56,6 +56,8 @@
   /* get reference to the connection */
   Egxp_Connection * conn = EGXP_EXTENSION(x)->parent->connection;
   egxp_connection_send_message (conn, message, 0);
+
+  return 1;
 }
 
 Egxp_Message * xmpp_message_iq (char * type, char * id, char * to) {
@@ -81,7 +83,14 @@
 
 
 Egxp_Message * xmpp_message_query (char * xmlns) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_message_query\n");
+#endif 
+  assert (xmlns);
+  
+  /* build the query message */
   Egxp_Message * message = egxp_message_new (XMPP_TAG_QUERY);
+  /* set the xmlns attribute */
   egxp_message_add_attribute (message, 
 			      egxp_message_attribute_new (XMPP_ATT_XMLNS, 
 							  xmlns));

Modified: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/xmpp_opcode.c	2005-02-17 22:52:14 UTC (rev 16)
@@ -36,6 +36,8 @@
   /* *************** */
   /*     stream      */
   egxp_opcode_add (eg->opcodes, XMPP_TAG_STREAM);
+  egxp_opcode_add (eg->opcodes, XMPP_TAG_IQ);
+  egxp_opcode_add (eg->opcodes, XMPP_TAG_QUERY);
   
   egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS);
   egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS_STREAM);
@@ -45,7 +47,29 @@
   egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_VERSION);
   
   
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_TYPE);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_TO);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_VERSION);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_ID);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_JID);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_FROM);
+  egxp_opcode_add (eg->opcodes, XMPP_ATT_NAME);
+
   
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_IQ_GET);
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_IQ_SET);
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_IQ_RESULT);
+  
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_QUERY_AUTH);
+  
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_IQ_AUTH_1);
+  egxp_opcode_add (eg->opcodes, XMPP_VALUE_IQ_AUTH_2);
+
+  // egxp_opcode_add (eg->opcodes, );
+  
+  
+
   /********************/
   /********************/
   /*  Protocol Init   */
@@ -62,5 +86,18 @@
 						       egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_STREAM_XMLNS_STREAM)));
   
   egxp_node_set_cb (stream, xmpp_callback_stream_begin_cb, NULL);
+
+
+  /* maybe put this inside the xmpp_auth */
+  /* define iq type='result' id='auth_1' */
+  Egxp_Node * iq = egxp_node_new (egxp_opcode_get_id (eg->opcodes, XMPP_TAG_IQ));
+  egxp_node_add_child (stream, iq);
+  /* type = result */
+  egxp_node_add_condition (iq, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_TYPE),
+						   egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_IQ_RESULT)));
+  egxp_node_add_condition (iq, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_ID),
+						   egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_IQ_AUTH_1)));
+  /* attach callback */
   
+
 }

Modified: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-15 21:57:22 UTC (rev 15)
+++ src/xmpp/xmpp_opcode.h	2005-02-17 22:52:14 UTC (rev 16)
@@ -52,9 +52,14 @@
 
 #define XMPP_VALUE_IQ_GET       "get"
 #define XMPP_VALUE_IQ_SET       "set"
+#define XMPP_VALUE_IQ_RESULT    "result"
 
 #define XMPP_VALUE_QUERY_AUTH   "jabber:iq:auth"
 
+#define XMPP_VALUE_IQ_AUTH_1    "auth_1"
+#define XMPP_VALUE_IQ_AUTH_2    "auth_2"
+
+
 /**
  * Add the xmpp opcode inside the opcode variable
  * @param opcode: use to store xmpp opcode



From jol at sheep.berlios.de  Fri Feb 18 11:38:51 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Fri, 18 Feb 2005 11:38:51 +0100
Subject: [Eim-svn] r17 - / src/egxp src/xmpp
Message-ID: <200502181038.j1IAcp2o031832@sheep.berlios.de>

Author: jol
Date: 2005-02-18 11:38:50 +0100 (Fri, 18 Feb 2005)
New Revision: 17

Modified:
   ChangeLog
   src/egxp/egxp_opcode.c
   src/egxp/egxp_protocol_handler.c
   src/xmpp/test.c
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
Log:
It should have no more memory leaks from eim
- Fix memory leaks
- rename egxp_opcode_display to egxp_opcode_free
- fix the egxp_opcode_add, when you try to add an existing element it is not added
  and it return the good id.
- in the xmpp/test place the egxp_free before the ecore_shutdown.



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-17 22:52:14 UTC (rev 16)
+++ ChangeLog	2005-02-18 10:38:50 UTC (rev 17)
@@ -1,3 +1,10 @@
+2005-02-19(jol):
+	- Fix memory leaks
+	- rename egxp_opcode_display to egxp_opcode_free
+	- fix the egxp_opcode_add, when you try to add an existing element it is not added
+	  and it return the good id.
+	- in the xmpp/test place the egxp_free before the ecore_shutdown.
+	
 2005-02-18(jol):
 	- Try to fix some memory leaks
 	

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-17 22:52:14 UTC (rev 16)
+++ src/egxp/egxp_opcode.c	2005-02-18 10:38:50 UTC (rev 17)
@@ -65,11 +65,20 @@
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_opcode_add\n");
 #endif
-
+  
   assert (op && name);
   
+  int * id = NULL;
+  /* check if the name already exist */
+  if ( (id = ecore_hash_get (op->string_id, (char*) name)) != NULL) {
+#ifdef EGXP_DEBUG
+    printf("TRACE: egxp_opcode_add -> %s already exists\n", name);
+#endif 
+    return *id;
+  }
+
   /* allocate the memory for the id */
-  int * id = (int*) malloc (sizeof (int));
+  id = (int*) malloc (sizeof (int));
   *id = op->id++;
   
 #ifdef EGXP_DEBUG

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-17 22:52:14 UTC (rev 16)
+++ src/egxp/egxp_protocol_handler.c	2005-02-18 10:38:50 UTC (rev 17)
@@ -169,8 +169,6 @@
 #endif   
     ph->current_msg = ph->current_msg->parent;
   }
-  
-  assert (ph->current_msg);
 }
 
 

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-17 22:52:14 UTC (rev 16)
+++ src/xmpp/test.c	2005-02-18 10:38:50 UTC (rev 17)
@@ -23,7 +23,8 @@
   }
 
   /* initialize ecore connection */
-  ecore_con_init();
+  ecore_init();
+  ecore_con_init ();
 
   /* create Egxp  */
   Egxp * eg = egxp_new ();
@@ -32,7 +33,7 @@
   Xmpp * xm = xmpp_register (eg);
   
   /* after 3 second we quit the ecore loop */
-  ecore_timer_add (5, timer_cb, NULL);
+  Ecore_Timer * timer = ecore_timer_add (5, timer_cb, NULL);
   printf("Quit automaticly (after 5 seconds)\n");
   
   /* define the connection */
@@ -46,18 +47,18 @@
   /* define the jid */
   xm->jid = xmpp_jid_new (argv[1], argv[2], "eim");
   
-  egxp_opcode_display (eg->opcodes);
-
   /* now we can send a message to the server */
   xmpp_message_stream (xm);
 
   /* ecore loop */
   ecore_main_loop_begin();
-  /* shutdown */
-  ecore_con_shutdown();
   
   /* free Egxp */
   egxp_free (eg);
   
+  /* shutdown */
+  ecore_con_shutdown ();
+  ecore_shutdown();
+  
   return 0;
 }

Modified: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-17 22:52:14 UTC (rev 16)
+++ src/xmpp/xmpp_opcode.c	2005-02-18 10:38:50 UTC (rev 17)
@@ -42,7 +42,6 @@
   egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS);
   egxp_opcode_add (eg->opcodes, XMPP_ATT_XMLNS_STREAM);
   
-  egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_XMLNS);
   egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_XMLNS_STREAM);
   egxp_opcode_add (eg->opcodes, XMPP_VALUE_STREAM_VERSION);
   

Modified: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-17 22:52:14 UTC (rev 16)
+++ src/xmpp/xmpp_opcode.h	2005-02-18 10:38:50 UTC (rev 17)
@@ -32,7 +32,6 @@
 
 #define XMPP_TAG_USERNAME       "username"
 
-#define XMPP_ATT_XMLNS          "xmlns"
 #define XMPP_ATT_XMLNS_STREAM   "xmlns:stream"
 
 #define XMPP_VALUE_STREAM_XMLNS          "jabber:client"



From jol at sheep.berlios.de  Fri Feb 18 11:47:01 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Fri, 18 Feb 2005 11:47:01 +0100
Subject: [Eim-svn] r18 - / src/egxp
Message-ID: <200502181047.j1IAl1X6032087@sheep.berlios.de>

Author: jol
Date: 2005-02-18 11:47:00 +0100 (Fri, 18 Feb 2005)
New Revision: 18

Modified:
   ChangeLog
   src/egxp/egxp_opcode.c
   src/egxp/egxp_opcode.h
Log:
-forgot to rename the egxp_opcode_display to egxp_opcode_print :p


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-18 10:38:50 UTC (rev 17)
+++ ChangeLog	2005-02-18 10:47:00 UTC (rev 18)
@@ -1,6 +1,6 @@
 2005-02-19(jol):
 	- Fix memory leaks
-	- rename egxp_opcode_display to egxp_opcode_free
+	- rename egxp_opcode_display to egxp_opcode_print
 	- fix the egxp_opcode_add, when you try to add an existing element it is not added
 	  and it return the good id.
 	- in the xmpp/test place the egxp_free before the ecore_shutdown.

Modified: src/egxp/egxp_opcode.c
===================================================================
--- src/egxp/egxp_opcode.c	2005-02-18 10:38:50 UTC (rev 17)
+++ src/egxp/egxp_opcode.c	2005-02-18 10:47:00 UTC (rev 18)
@@ -152,9 +152,9 @@
 }
 
 
-void egxp_opcode_display (Egxp_Opcode * op) {
+void egxp_opcode_print (Egxp_Opcode * op) {
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_opcode_display\n");
+  printf("TRACE: egxp_opcode_print\n");
 #endif
   int i;
   assert (op);

Modified: src/egxp/egxp_opcode.h
===================================================================
--- src/egxp/egxp_opcode.h	2005-02-18 10:38:50 UTC (rev 17)
+++ src/egxp/egxp_opcode.h	2005-02-18 10:47:00 UTC (rev 18)
@@ -93,8 +93,9 @@
 
 
 /**
- * Display the contents of grammar
+ * Display all registered opcodes
+ * @param p: the opcode to print
  */
-void egxp_opcode_display (Egxp_Opcode * op);
+void egxp_opcode_print(Egxp_Opcode * op);
 
 #endif



From ylloh at sheep.berlios.de  Fri Feb 18 22:00:05 2005
From: ylloh at sheep.berlios.de (Holger Dell at BerliOS)
Date: Fri, 18 Feb 2005 22:00:05 +0100
Subject: [Eim-svn] r19 - src/egxp
Message-ID: <200502182100.j1IL05XA027899@sheep.berlios.de>

Author: ylloh
Date: 2005-02-18 22:00:04 +0100 (Fri, 18 Feb 2005)
New Revision: 19

Modified:
   src/egxp/test.c
Log:
- you forgot to replace a call of egxp_opcode_display by egxp_opcode_print.


Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-18 10:47:00 UTC (rev 18)
+++ src/egxp/test.c	2005-02-18 21:00:04 UTC (rev 19)
@@ -39,7 +39,7 @@
   
 
   /* display information about opcode */
-  egxp_opcode_display (eg->opcodes);
+  egxp_opcode_print (eg->opcodes);
   
   
 



From jol at sheep.berlios.de  Sun Feb 20 23:12:09 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Sun, 20 Feb 2005 23:12:09 +0100
Subject: [Eim-svn] r20 - / src/egxp src/xmpp
Message-ID: <200502202212.j1KMC9iV027255@sheep.berlios.de>

Author: jol
Date: 2005-02-20 23:12:08 +0100 (Sun, 20 Feb 2005)
New Revision: 20

Added:
   src/xmpp/sha1.c
   src/xmpp/sha1.h
Modified:
   ChangeLog
   src/egxp/egxp.c
   src/egxp/egxp_connection.c
   src/egxp/egxp_message.c
   src/egxp/egxp_message.h
   src/egxp/egxp_protocol_handler.c
   src/egxp/test.c
   src/xmpp/Makefile.am
   src/xmpp/test.c
   src/xmpp/xmpp_auth.c
   src/xmpp/xmpp_auth.h
   src/xmpp/xmpp_opcode.c
   src/xmpp/xmpp_opcode.h
Log:
- add egxp_message_root allowing to get the root message of a message.
- try to fix memory leaks and a dirty segfault.
- The segfault is always here i'm hunting it !
- add sha1 support to use with password.


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-18 21:00:04 UTC (rev 19)
+++ ChangeLog	2005-02-20 22:12:08 UTC (rev 20)
@@ -1,3 +1,9 @@
+2005-02-20(jol):
+	- add egxp_message_root allowing to get the root message of a message.
+	- try to fix memory leaks and a dirty segfault.
+	- The segfault is always here i'm hunting it !
+	- add sha1 support to use with password.
+	
 2005-02-19(jol):
 	- Fix memory leaks
 	- rename egxp_opcode_display to egxp_opcode_print

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/egxp.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -75,7 +75,7 @@
   if (e->connection) egxp_connection_free (e->connection);
   /* free extension */
   if (e->extensions) ecore_hash_destroy (e->extensions);
-  free (e);
+  FREE (e);
 }
 
 

Modified: src/egxp/egxp_connection.c
===================================================================
--- src/egxp/egxp_connection.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/egxp_connection.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -110,7 +110,7 @@
   if (c->server) {
     /* warning FIXME, i don't how close connection work ... */
     printf("egxp_connection_disconnect:: FIXME %s\n", __FILE__);
-    // ecore_con_server_del (c->server);
+    ecore_con_server_del (c->server);
     c->server = NULL;
   }
 }

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/egxp_message.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -59,12 +59,12 @@
 
 
 void egxp_message_free (Egxp_Message * m) {
+  assert (m);
 #ifdef EGXP_DEBUG
-  printf("TRACE: egxp_message_free\n");
+  char * debug = strdup (m->tagname);
+  printf("TRACE: egxp_message_free -> begin: %s\n", debug);
 #endif
   
-  assert (m);
-  
   FREE (m->tagname);
   ecore_list_destroy (m->attributes);
   ecore_list_destroy (m->childs);
@@ -73,8 +73,15 @@
   if (m->parent) {
     // egxp_message_remove_child (m->parent, m);
   }
-  IF_FREE (m->data);
+  m->parent = NULL;
+
+ IF_FREE (m->data);
   FREE (m);
+  
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_free -> end: %s\n", debug);
+  FREE (debug);
+#endif
 }
 
 Egxp_Message * egxp_message_get_child (Egxp_Message *m, char * tagname) {
@@ -161,7 +168,7 @@
 
   ecore_list_goto_first(m->childs);
   Egxp_Message * list_item;
-  while((list_item = (Egxp_Message*)ecore_list_next(m->childs)) != NULL) {
+  while((list_item = EGXP_MESSAGE(ecore_list_next(m->childs))) != NULL) {
     if (ma == list_item) {
       ecore_list_remove (m->childs);
       return;
@@ -288,7 +295,7 @@
     // the termination tag
     if (endtag) {
       len = strlen (m->tagname);
-      buf_len += len + 3; // <tagname/>
+      buf_len += len + 3; // </tagname>
       buf = (char*) realloc (buf, buf_len);
       buf = strncat (buf, "</",2);
       buf = strncat (buf, m->tagname, len);
@@ -309,6 +316,20 @@
 }
 
 
+Egxp_Message * egxp_message_root (Egxp_Message * m) {
+#ifdef EGXP_DEBUG
+  printf("TRACE: egxp_message_root\n");
+#endif
+  assert (m != NULL);
+  
+  /* if the parent is null we return this message */
+  if (m->parent == NULL) return m;
+  /* else we return the root of the parent */
+  return egxp_message_root (m->parent);
+}
+
+
+
 unsigned int egxp_message_is_empty (Egxp_Message *m) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_message_is_empty\n");
@@ -322,6 +343,8 @@
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_message_attribute_new\n");
 #endif
+  assert (key && value);
+  
   Egxp_MessageAttribute * tmp = (Egxp_MessageAttribute *) malloc (sizeof (Egxp_MessageAttribute));
   
   tmp->key = strdup (key);
@@ -334,9 +357,9 @@
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_message_attribute_free\n");
 #endif
+  
+  assert (ma);
 
-  if (ma == NULL) return;
-  
   FREE (ma->key);
   FREE (ma->value);
   FREE (ma);

Modified: src/egxp/egxp_message.h
===================================================================
--- src/egxp/egxp_message.h	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/egxp_message.h	2005-02-20 22:12:08 UTC (rev 20)
@@ -170,13 +170,22 @@
  */
 char * egxp_message_to_xml (Egxp_Message *m, unsigned int endtag);
 
+/**
+ * Display the xml representation of the message
+ * @param m: The message to display
+ */
 void egxp_message_print(Egxp_Message *m);
 
+/**
+ * Return the root message.
+ * @param m: a message
+ * @return the root message or null if no message.
+ */
+Egxp_Message * egxp_message_root (Egxp_Message * m);
 
 
 
 
-
 /**
  * Create a Egxp_MessageAttribute
  */

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/egxp_protocol_handler.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -32,7 +32,7 @@
 void egxp_protocol_handler_char_data (void *userData, const XML_Char *s, int len);
 
 
-Egxp_ProtocolHandler * egxp_protocol_handler_new (struct _Egxp * e) {
+Egxp_ProtocolHandler * egxp_protocol_handler_new (Egxp * e) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_protocol_handler_new\n");
 #endif 
@@ -45,16 +45,18 @@
 
   /* initialize the xml parser */
   tmp->parser = XML_ParserCreate(NULL);
+  /* define the data pass as parameter during callback call. */
   XML_SetUserData(tmp->parser, e);
+  /* define callback */
   XML_SetElementHandler(tmp->parser, 
 			egxp_protocol_handler_start_element, 
 			egxp_protocol_handler_end_element);
   XML_SetCharacterDataHandler(tmp->parser,  egxp_protocol_handler_char_data);
-
+  
   /* initialize the protocol stack */
   tmp->protocol_stack = e->root;
   assert (tmp->protocol_stack != NULL);
-
+  
   return tmp;
 }
 
@@ -70,18 +72,16 @@
 
   /* do we need to free the message ? */
   if (ph->current_msg) {
-    egxp_message_free (ph->current_msg);
+    /* free the root to be sure that we forget no message */
+    egxp_message_free (egxp_message_root (ph->current_msg));
+    ph->current_msg = NULL;
   }
-  
-  free (ph);
+  FREE (ph);
 }
 
 
 
 
-
-
-
 void egxp_protocol_handler_start_element(void *userData, const char *name, const char **atts) {
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_protocol_handler_start_element : %s\n", name);
@@ -115,6 +115,7 @@
   
   /* manage protocol */
   assert (ph->protocol_stack);
+  assert (ph->current_msg);
   
   /* try to get the Egxp_Node correspond to the tag id and parameter */
   node = egxp_protocol_handler_get_node (ph->protocol_stack, message, eg->opcodes);
@@ -138,11 +139,8 @@
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   
   assert (eg && ph);
-  
   assert (ph->current_msg);
   
-  egxp_message_print(ph->current_msg);
-  
   /* check if the current message is equal to the current protocol stack node */
   if (egxp_protocol_handler_equals (ph->protocol_stack, ph->current_msg, eg->opcodes)) {
     

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/egxp/test.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -38,7 +38,6 @@
   egxp_opcode_add (eg->opcodes, "set");
   
 
-  /* display information about opcode */
   egxp_opcode_print (eg->opcodes);
   
   
@@ -78,6 +77,10 @@
   
   /* create a stream message without attribute */
   Egxp_Message * mesg1 = egxp_message_new ("stream");
+  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("fr", "sd"));
+  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("dfr", "sd"));
+  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("ffr", "sd"));
+  egxp_message_add_attribute (mesg1, egxp_message_attribute_new ("gfr", "sd"));
   /* test if it's possible to get the node from the egxp protocol handler */
   n1 = egxp_protocol_handler_get_node (eg->protocol_handler->protocol_stack,
                                        mesg1, eg->opcodes);
@@ -94,6 +97,9 @@
   /* create a iq message with one attributes */
   Egxp_Message * mesg2 = egxp_message_new ("iq");
   egxp_message_add_attribute (mesg2, egxp_message_attribute_new ("type", "get"));
+  egxp_message_add_attribute (mesg2, egxp_message_attribute_new ("atype", "eget"));
+  egxp_message_add_attribute (mesg2, egxp_message_attribute_new ("ntype", "aget"));
+  egxp_message_add_attribute (mesg2, egxp_message_attribute_new ("dtype", "gfget"));
   /* test if it's possible to get the node from the egxp protocol handler */
   printf("Get iq node from protocol handler(it should not be null): %p\n",
          egxp_protocol_handler_get_node (n1, mesg2, eg->opcodes));
@@ -103,6 +109,12 @@
   /* free the message */
   // egxp_message_free (mesg1);
   
+  int i;
+  for (i = 0; i < 1000 ; i++) {
+    char * buf = egxp_message_to_xml (mesg1, 1);
+    printf("%s\n%d\n", buf, strlen (buf));
+    free (buf);
+  }
   
   /* free opcode */
   egxp_free (eg);

Modified: src/xmpp/Makefile.am
===================================================================
--- src/xmpp/Makefile.am	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/Makefile.am	2005-02-20 22:12:08 UTC (rev 20)
@@ -18,7 +18,8 @@
 	xmpp.h           \
 	xmpp_jid.h       \
 	xmpp_message.h   \
-	xmpp_auth.h
+	xmpp_auth.h      \
+	sha1.h
 
 libxmpp_la_SOURCES = \
 	xmpp_opcode.c    \
@@ -26,6 +27,7 @@
 	xmpp.c           \
 	xmpp_jid.c       \
 	xmpp_message.c   \
-	xmpp_auth.c
+	xmpp_auth.c      \
+	sha1.c
 
 libxmpp_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE) -I$(top_srcdir)/src

Added: src/xmpp/sha1.c
===================================================================
--- src/xmpp/sha1.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/sha1.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -0,0 +1,163 @@
+/* 
+ * The contents of this file are subject to the Mozilla Public
+ * License Version 1.1 (the "License"); you may not use this file
+ * except in compliance with the License. You may obtain a copy of
+ * the License at http://www.mozilla.org/MPL/
+ * 
+ * Software distributed under the License is distributed on an "AS
+ * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ * implied. See the License for the specific language governing
+ * rights and limitations under the License.
+ * 
+ * The Original Code is SHA 180-1 Reference Implementation (Compact version)
+ * 
+ * The Initial Developer of the Original Code is Paul Kocher of
+ * Cryptography Research.  Portions created by Paul Kocher are 
+ * Copyright (C) 1995-9 by Cryptography Research, Inc.  All
+ * Rights Reserved.
+ * 
+ */
+
+/* modified for j2 by Robert Norris */
+
+#include "sha1.h"
+#include <string.h>
+
+static void sha1_hashblock(sha1_state_t *ctx);
+
+void sha1_init(sha1_state_t *ctx) {
+  int i;
+
+  ctx->lenW = 0;
+  ctx->sizeHi = ctx->sizeLo = 0;
+
+  /* Initialize H with the magic constants (see FIPS180 for constants)
+   */
+  ctx->H[0] = 0x67452301L;
+  ctx->H[1] = 0xefcdab89L;
+  ctx->H[2] = 0x98badcfeL;
+  ctx->H[3] = 0x10325476L;
+  ctx->H[4] = 0xc3d2e1f0L;
+
+  for (i = 0; i < 80; i++)
+    ctx->W[i] = 0;
+}
+
+
+void sha1_append(sha1_state_t *ctx, const unsigned char *dataIn, int len) {
+  int i;
+
+  /* Read the data into W and process blocks as they get full
+   */
+  for (i = 0; i < len; i++) {
+    ctx->W[ctx->lenW / 4] <<= 8;
+    ctx->W[ctx->lenW / 4] |= (unsigned long)dataIn[i];
+    if ((++ctx->lenW) % 64 == 0) {
+      sha1_hashblock(ctx);
+      ctx->lenW = 0;
+    }
+    ctx->sizeLo += 8;
+    ctx->sizeHi += (ctx->sizeLo < 8);
+  }
+}
+
+
+void sha1_finish(sha1_state_t *ctx, unsigned char hashout[20]) {
+  unsigned char pad0x80 = 0x80;
+  unsigned char pad0x00 = 0x00;
+  unsigned char padlen[8];
+  int i;
+
+  /* Pad with a binary 1 (e.g. 0x80), then zeroes, then length
+   */
+  padlen[0] = (unsigned char)((ctx->sizeHi >> 24) & 255);
+  padlen[1] = (unsigned char)((ctx->sizeHi >> 16) & 255);
+  padlen[2] = (unsigned char)((ctx->sizeHi >> 8) & 255);
+  padlen[3] = (unsigned char)((ctx->sizeHi >> 0) & 255);
+  padlen[4] = (unsigned char)((ctx->sizeLo >> 24) & 255);
+  padlen[5] = (unsigned char)((ctx->sizeLo >> 16) & 255);
+  padlen[6] = (unsigned char)((ctx->sizeLo >> 8) & 255);
+  padlen[7] = (unsigned char)((ctx->sizeLo >> 0) & 255);
+  sha1_append(ctx, &pad0x80, 1);
+  while (ctx->lenW != 56)
+    sha1_append(ctx, &pad0x00, 1);
+  sha1_append(ctx, padlen, 8);
+
+  /* Output hash
+   */
+  for (i = 0; i < 20; i++) {
+    hashout[i] = (unsigned char)(ctx->H[i / 4] >> 24);
+    ctx->H[i / 4] <<= 8;
+  }
+
+  /*
+   *  Re-initialize the context (also zeroizes contents)
+   */
+  sha1_init(ctx); 
+}
+
+
+void sha1_hash(const unsigned char *dataIn, int len, unsigned char hashout[20]) {
+  sha1_state_t ctx;
+
+  sha1_init(&ctx);
+  sha1_append(&ctx, dataIn, len);
+  sha1_finish(&ctx, hashout);
+}
+
+
+#define SHA_ROTL(X,n) ((((X) << (n)) | ((X) >> (32-(n)))) & 0xffffffffL)
+
+static void sha1_hashblock(sha1_state_t *ctx) {
+  int t;
+  unsigned long A,B,C,D,E,TEMP;
+
+  for (t = 16; t <= 79; t++)
+    ctx->W[t] =
+      SHA_ROTL(ctx->W[t-3] ^ ctx->W[t-8] ^ ctx->W[t-14] ^ ctx->W[t-16], 1);
+
+  A = ctx->H[0];
+  B = ctx->H[1];
+  C = ctx->H[2];
+  D = ctx->H[3];
+  E = ctx->H[4];
+
+  for (t = 0; t <= 19; t++) {
+    TEMP = (SHA_ROTL(A,5) + (((C^D)&B)^D)     + E + ctx->W[t] + 0x5a827999L) & 0xffffffffL;
+    E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+  }
+  for (t = 20; t <= 39; t++) {
+    TEMP = (SHA_ROTL(A,5) + (B^C^D)           + E + ctx->W[t] + 0x6ed9eba1L) & 0xffffffffL;
+    E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+  }
+  for (t = 40; t <= 59; t++) {
+    TEMP = (SHA_ROTL(A,5) + ((B&C)|(D&(B|C))) + E + ctx->W[t] + 0x8f1bbcdcL) & 0xffffffffL;
+    E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+  }
+  for (t = 60; t <= 79; t++) {
+    TEMP = (SHA_ROTL(A,5) + (B^C^D)           + E + ctx->W[t] + 0xca62c1d6L) & 0xffffffffL;
+    E = D; D = C; C = SHA_ROTL(B, 30); B = A; A = TEMP;
+  }
+
+  ctx->H[0] += A;
+  ctx->H[1] += B;
+  ctx->H[2] += C;
+  ctx->H[3] += D;
+  ctx->H[4] += E;
+}
+
+
+/** turn raw into hex - out must be (inlen*2)+1 */
+void hex_from_raw(char *in, int inlen, char *out) {
+    int i, h, l;
+
+    for(i = 0; i < inlen; i++) {
+        h = in[i] & 0xf0;
+        h >>= 4;
+        l = in[i] & 0x0f;
+        out[i * 2] = (h >= 0x0 && h <= 0x9) ? (h + 0x30) : (h + 0x57);
+        out[i * 2 + 1] = (l >= 0x0 && l <= 0x9) ? (l + 0x30) : (l + 0x57);
+    }
+    out[i * 2] = '\0';
+}
+

Added: src/xmpp/sha1.h
===================================================================
--- src/xmpp/sha1.h	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/sha1.h	2005-02-20 22:12:08 UTC (rev 20)
@@ -0,0 +1,43 @@
+/*
+ * jabberd - Jabber Open Source Server
+ * Copyright (c) 2002-2003 Jeremie Miller, Thomas Muldowney,
+ *                         Ryan Eatmon, Robert Norris
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA
+ */
+
+/* sha1 functions */
+
+#ifndef INCL_SHA1_H
+#define INCL_SHA1_H
+
+typedef struct sha1_state_s {
+  unsigned long H[5];
+  unsigned long W[80];
+  int lenW;
+  unsigned long sizeHi,sizeLo;
+} sha1_state_t;
+
+void sha1_init(sha1_state_t *ctx);
+void sha1_append(sha1_state_t *ctx, const unsigned char *dataIn, int len);
+void sha1_finish(sha1_state_t *ctx, unsigned char hashout[20]);
+void sha1_hash(const unsigned char *dataIn, int len, unsigned char hashout[20]);
+
+
+/** turn raw into hex - out must be (inlen*2)+1 */
+void hex_from_raw(char *in, int inlen, char *out);
+
+
+#endif

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/test.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -33,8 +33,8 @@
   Xmpp * xm = xmpp_register (eg);
   
   /* after 3 second we quit the ecore loop */
-  Ecore_Timer * timer = ecore_timer_add (5, timer_cb, NULL);
-  printf("Quit automaticly (after 5 seconds)\n");
+  Ecore_Timer * timer = ecore_timer_add (15, timer_cb, NULL);
+  printf("Quit automaticly (after 15 seconds)\n");
   
   /* define the connection */
   eg->connection = egxp_connection_new (argv[2], atoi (argv[3]), 0);
@@ -54,6 +54,8 @@
   ecore_main_loop_begin();
   
   /* free Egxp */
+  egxp_message_print(eg->protocol_handler->current_msg);
+
   egxp_free (eg);
   
   /* shutdown */

Modified: src/xmpp/xmpp_auth.c
===================================================================
--- src/xmpp/xmpp_auth.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/xmpp_auth.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -3,7 +3,11 @@
 #include <stdio.h>
 
 #include <Ecore_Data.h>
+
+#include "egxp/egxp_message.h"
+
 #include "xmpp.h"
+#include "sha1.h"
 
 #include "xmpp_auth.h"
 
@@ -11,7 +15,7 @@
 #ifdef XMPP_DEBUG
   printf("TRACE: xmpp_auth_new\n");
 #endif
-
+  
   /* initialize the structure */
   Xmpp_Auth * auth = XMPP_AUTH(malloc (sizeof(Xmpp_Auth)));
   
@@ -43,7 +47,7 @@
   printf("TRACE: xmpp_auth_msg_no_sasl\n");
 #endif
   assert (x);
- 
+  
   /* create the iq type="get" */
   Egxp_Message * iq = xmpp_message_iq (XMPP_VALUE_IQ_GET, "auth_1", 
 				       x->jid->host);
@@ -61,3 +65,85 @@
   Egxp_Connection * conn = EGXP_EXTENSION(x)->parent->connection;
   egxp_connection_send_message (conn, iq, 1);
 }
+
+
+
+void xmpp_auth_auth_1_cb (Egxp_Message * msg, void * eg) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_auth_auth_1_cb\n");
+#endif
+  /**
+   * When we received this message it is because we have succeed
+   * the first non-sasl step or there is an error ?. Now in 
+   * function of the reply of the server we should 
+   * send good information
+   */
+  assert (msg && eg);
+  
+  /* get the xmpp protocol */
+  Xmpp * xm = XMPP( egxp_extension_get_from_string (EGXP(eg), XMPP_REGISTER));
+  assert (xm);
+
+  /* now analyse the response of the server */
+  /* try to get the query */
+  Egxp_Message * received_query = egxp_message_get_child (msg,  XMPP_TAG_QUERY);
+  if (received_query == NULL) {
+    egxp_message_print (msg);
+    assert (0);
+  }
+  /* FIXME: Technically we should test the response of the server to know what
+     type of message we need to send */
+
+
+
+  /* begin to build our response */
+  /* iq type=set id=auth_2 to=... */
+  Egxp_Message * iq = xmpp_message_iq (XMPP_VALUE_IQ_SET, 
+				       XMPP_VALUE_IQ_AUTH_2,
+				       xm->jid->host);
+  /* query xmlns= "jabber:iq:auth" */
+  Egxp_Message * query = xmpp_message_query (XMPP_VALUE_QUERY_AUTH);
+  egxp_message_add_child (iq, query);
+  
+  /* create username */
+  Egxp_Message * username = egxp_message_new (XMPP_TAG_USERNAME);
+  egxp_message_append_data (username, xm->jid->user, strlen (xm->jid->user));
+  egxp_message_add_child (query, username);
+  
+  /* create password */
+  if(xm->auth && xm->auth->password && xm->auth->stream_id) {
+    Egxp_Message * password = egxp_message_new (XMPP_TAG_PASSWORD);
+    /* build the digest data */
+    sha1_state_t sha1;
+    char sha1_hash[20];
+    sha1_init(&sha1);
+    sha1_append (&sha1, xm->auth->stream_id, strlen (xm->auth->stream_id));
+    sha1_append (&sha1, xm->auth->password, strlen (xm->auth->password));
+    sha1_finish (&sha1, sha1_hash);
+    char sha1_hex[41];
+    hex_from_raw (sha1_hash, 20, sha1_hex);
+    /* add the data to the password message */
+    egxp_message_append_data (password, sha1_hex, 41);
+    egxp_message_add_child (query, password);
+  } else {
+#ifdef XMPP_DEBUG
+    printf("DEBUG: xmpp_auth_auth_1_cb -> The auth seems to be null or the password and stream_id are null\n");
+#endif
+  }
+  
+  /* try to append resource */
+  if (xm->jid->resource) {
+    Egxp_Message * resource = egxp_message_new (XMPP_TAG_RESOURCE);
+    egxp_message_append_data (resource, xm->jid->resource, strlen (xm->jid->resource));
+    egxp_message_add_child (query, resource);
+  } else {
+#ifdef XMPP_DEBUG
+    printf("DEBUG: xmpp_auth_auth_1_cb -> It seems that you haven't define resource\n");
+#endif 
+  }
+
+  /* now we can try to send the message */
+  // Egxp_Connection * conn = EGXP_EXTENSION(xm)->parent->connection;
+  //egxp_connection_send_message (conn, iq, 1);
+  egxp_message_free (iq);
+}

Modified: src/xmpp/xmpp_auth.h
===================================================================
--- src/xmpp/xmpp_auth.h	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/xmpp_auth.h	2005-02-20 22:12:08 UTC (rev 20)
@@ -21,6 +21,7 @@
 
 /**
  * Initialize the structure
+ * @return the newly allocated structure
  */
 Xmpp_Auth * xmpp_auth_new ();
 
@@ -29,6 +30,7 @@
  * Free the authentification structure
  * - free the password
  * - free the stream id
+ * @param a: The Authentification structure to be freed.
  */
 void xmpp_auth_free (Xmpp_Auth * a);
 
@@ -37,7 +39,17 @@
 /**
  * Send a message to try to be authenticiate in
  * no SASL mode
+ * @param x: The Xmpp structure
  */
 void xmpp_auth_msg_no_sasl (struct _Xmpp * x);
 
+
+/**
+ * This method is called when the server return the response
+ * of the query auth_1 (the first step of the non-sasl auth).
+ * @param msg: The message
+ * @param eg: The Egxp object
+ */
+void xmpp_auth_auth_1_cb (Egxp_Message * msg, void * eg);
+
 #endif

Modified: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/xmpp_opcode.c	2005-02-20 22:12:08 UTC (rev 20)
@@ -23,6 +23,7 @@
 #include "egxp/egxp_node.h"
 
 #include "xmpp_callback.h"
+#include "xmpp_auth.h"
 #include "xmpp_opcode.h"
 
 void xmpp_opcode_init (Egxp * eg) {
@@ -97,6 +98,6 @@
   egxp_node_add_condition (iq, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_ID),
 						   egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_IQ_AUTH_1)));
   /* attach callback */
+  // egxp_node_set_cb (iq, NULL, xmpp_auth_auth_1_cb);
   
-
 }

Modified: src/xmpp/xmpp_opcode.h
===================================================================
--- src/xmpp/xmpp_opcode.h	2005-02-18 21:00:04 UTC (rev 19)
+++ src/xmpp/xmpp_opcode.h	2005-02-20 22:12:08 UTC (rev 20)
@@ -31,6 +31,8 @@
 #define XMPP_TAG_QUERY  "query"
 
 #define XMPP_TAG_USERNAME       "username"
+#define XMPP_TAG_PASSWORD       "digest"
+#define XMPP_TAG_RESOURCE       "resource"
 
 #define XMPP_ATT_XMLNS_STREAM   "xmlns:stream"
 



From jol at sheep.berlios.de  Wed Feb 23 23:36:14 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Wed, 23 Feb 2005 23:36:14 +0100
Subject: [Eim-svn] r21 - / src/egxp src/xmpp
Message-ID: <200502232236.j1NMaE8B006027@sheep.berlios.de>

Author: jol
Date: 2005-02-23 23:36:12 +0100 (Wed, 23 Feb 2005)
New Revision: 21

Modified:
   ChangeLog
   src/egxp/egxp.c
   src/egxp/egxp_connection.c
   src/egxp/egxp_message.c
   src/egxp/egxp_protocol_handler.c
   src/egxp/test.c
   src/xmpp/test.c
   src/xmpp/xmpp_auth.c
   src/xmpp/xmpp_auth.h
   src/xmpp/xmpp_callback.c
   src/xmpp/xmpp_opcode.c
Log:
- Fix the bug ! The message was not correctly remove from the child list
  of a message. The reason is that i didn't use correctly the ecore_list functions.
- Add some helpful functions.
- Now we are authentifiate near the server.
- There is no leaks from eim



Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-20 22:12:08 UTC (rev 20)
+++ ChangeLog	2005-02-23 22:36:12 UTC (rev 21)
@@ -1,3 +1,9 @@
+2005-02-24(jol):
+	- Fix the bug ! The message was not correctly remove from the child list
+	of a message. The reason is that i didn't use correctly the ecore_list functions.
+	- Add some helpful functions.
+	- Now we are authentifiate near the server.
+	
 2005-02-20(jol):
 	- add egxp_message_root allowing to get the root message of a message.
 	- try to fix memory leaks and a dirty segfault.

Modified: src/egxp/egxp.c
===================================================================
--- src/egxp/egxp.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/egxp/egxp.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -35,7 +35,7 @@
   
   /* the root of the protocol */
   tmp->root = egxp_node_new (egxp_opcode_get_id (tmp->opcodes, 
-						      "__ROOT__"));
+						 "__ROOT__"));
     
   /* initialize the user data */
   tmp->user_data = NULL;

Modified: src/egxp/egxp_connection.c
===================================================================
--- src/egxp/egxp_connection.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/egxp/egxp_connection.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -87,7 +87,7 @@
 
   // to xml
   char * buf = egxp_message_to_xml (msg, end_tag);
-  printf("log send: %s\nsize: %d\n", buf, strlen (buf));
+  printf("LOG egxp_connection_send_message: %s\nsize: %d\n", buf, strlen (buf));
   
   // free message
   egxp_message_free (msg);

Modified: src/egxp/egxp_message.c
===================================================================
--- src/egxp/egxp_message.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/egxp/egxp_message.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -71,13 +71,13 @@
   
   /* if attached to a parent, we remove the dependancies */
   if (m->parent) {
-    // egxp_message_remove_child (m->parent, m);
+    egxp_message_remove_child (m->parent, m);
   }
   m->parent = NULL;
 
  IF_FREE (m->data);
-  FREE (m);
-  
+ FREE (m);
+ 
 #ifdef EGXP_DEBUG
   printf("TRACE: egxp_message_free -> end: %s\n", debug);
   FREE (debug);
@@ -168,11 +168,15 @@
 
   ecore_list_goto_first(m->childs);
   Egxp_Message * list_item;
-  while((list_item = EGXP_MESSAGE(ecore_list_next(m->childs))) != NULL) {
+  while((list_item = EGXP_MESSAGE(ecore_list_current(m->childs))) != NULL) {
     if (ma == list_item) {
-      ecore_list_remove (m->childs);
+      if (! ecore_list_remove (m->childs)) {
+	printf("Remove Failed !!!!!!!!!!!!!!!!!!!! %s %s\n", m->tagname, list_item->tagname);
+	assert (0);
+      }
       return;
-    } 
+    }
+    ecore_list_next (m->childs);
   }
 }
 
@@ -230,7 +234,7 @@
 
   // "<tagname " + 3 -> \0
   len = strlen (m->tagname) + 3;
-  buf = (char*) calloc (len, sizeof (char));
+  buf = (char*) malloc (len * sizeof (char));
   buf = memset (buf, 0, len); 
   buf = strncat (buf, "<", 1);
   buf = strncat (buf, m->tagname, strlen (m->tagname));

Modified: src/egxp/egxp_protocol_handler.c
===================================================================
--- src/egxp/egxp_protocol_handler.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/egxp/egxp_protocol_handler.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -107,9 +107,12 @@
   
   /* attach the message */
   if (ph->current_msg == NULL) {
+    /* set the message as root message */
     ph->current_msg = message;
   } else {
+    /* add the new message to the root node */
     egxp_message_add_child (ph->current_msg, message);
+    /* the new message become the root */
     ph->current_msg = message;
   }
   
@@ -157,15 +160,22 @@
     /* go to the parent message and destroy the current message */
     Egxp_Message * old = ph->current_msg;
     ph->current_msg = old->parent;
-    if (ph->current_msg) egxp_message_remove_child (ph->current_msg, old);
+    
+    /* remove the old message */
     egxp_message_free (old);
-    
   } else {
 
 #ifdef EGXP_DEBUG
     printf("TRACE: egxp_protocol_handler_end_element -> NOT matches opcode : %s\n", name);
 #endif   
-    ph->current_msg = ph->current_msg->parent;
+    
+    /* if there is no parent we destroy the current message */
+    if (ph->current_msg->parent == NULL) {
+      egxp_message_free (ph->current_msg);
+      ph->current_msg = NULL;
+    }
+    /* other wise we continue */
+    else ph->current_msg = ph->current_msg->parent;
   }
 }
 
@@ -179,7 +189,7 @@
   Egxp * eg = EGXP (userData);
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   
-  assert (eg && ph);
+  assert (eg && ph && ph->current_msg);
   
   /* append data to the message */
   egxp_message_append_data ( ph->current_msg, (char*) s, len);
@@ -193,7 +203,7 @@
   printf("TRACE: egxp_protocol_handler_condition_equals\n");
 #endif
   assert (message && opcode);
-
+  
   /* if the node has no condition we can conclude that they are equals */
   if (conditions == NULL) return 1;
   
@@ -277,6 +287,8 @@
   Egxp_ProtocolHandler * ph = eg->protocol_handler;
   XML_Parser parser =  ph->parser;
   
+  assert (eg && ph && parser);
+
   char * tmp_buf = (char*) malloc ((ev->size +1) * sizeof (char));
   tmp_buf[ev->size] = '\0';
   strncpy (tmp_buf, (char*)ev->data, ev->size); 

Modified: src/egxp/test.c
===================================================================
--- src/egxp/test.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/egxp/test.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -106,6 +106,16 @@
   
   egxp_message_add_child (mesg1, mesg2);
 
+
+  egxp_message_append_data (mesg1, "terglkdfjgldsjglsdfjgldsfgsldkj",
+			    strlen ("terglkdfjgldsjglsdfjgldsfgsldkj"));
+  egxp_message_append_data (mesg1, "terglkdfjglaaaaaaaaaaadsjglsdfjgldsfgsldk",
+			    strlen("terglkdfjglaaaaaaaaaaadsjglsdfjgldsfgsldk")
+			    );
+  egxp_message_append_data (mesg1, "terglkdfjgldsjgl...sdfjgldsfgsldkj",
+			    strlen  ("terglkdfjgldsjgl...sdfjgldsfgsldkj"));
+  
+
   /* free the message */
   // egxp_message_free (mesg1);
   

Modified: src/xmpp/test.c
===================================================================
--- src/xmpp/test.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/xmpp/test.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -47,6 +47,9 @@
   /* define the jid */
   xm->jid = xmpp_jid_new (argv[1], argv[2], "eim");
   
+  /* define the password */
+  xm->auth = xmpp_auth_new_with_passwd (argv[4]);
+  
   /* now we can send a message to the server */
   xmpp_message_stream (xm);
 

Modified: src/xmpp/xmpp_auth.c
===================================================================
--- src/xmpp/xmpp_auth.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/xmpp/xmpp_auth.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -27,6 +27,17 @@
 }
 
 
+Xmpp_Auth * xmpp_auth_new_with_passwd (char * pwd) {
+#ifdef XMPP_DEBUG
+  printf("TRACE: xmpp_auth_new_with_passwd\n");
+#endif
+  Xmpp_Auth * tmp = xmpp_auth_new ();
+  /* load password */
+  tmp->password = strdup (pwd);
+  
+  return tmp;
+}
+
 void xmpp_auth_free (Xmpp_Auth * a) {
 #ifdef XMPP_DEBUG
   printf("TRACE: xmpp_auth_free\n");
@@ -141,9 +152,8 @@
     printf("DEBUG: xmpp_auth_auth_1_cb -> It seems that you haven't define resource\n");
 #endif 
   }
-
+  
   /* now we can try to send the message */
-  // Egxp_Connection * conn = EGXP_EXTENSION(xm)->parent->connection;
-  //egxp_connection_send_message (conn, iq, 1);
-  egxp_message_free (iq);
+  Egxp_Connection * conn = EGXP_EXTENSION(xm)->parent->connection;
+  egxp_connection_send_message (conn, iq, 1);
 }

Modified: src/xmpp/xmpp_auth.h
===================================================================
--- src/xmpp/xmpp_auth.h	2005-02-20 22:12:08 UTC (rev 20)
+++ src/xmpp/xmpp_auth.h	2005-02-23 22:36:12 UTC (rev 21)
@@ -27,6 +27,13 @@
 
 
 /**
+ * Initialize the structure with the password
+ * @return the newly allocated structure
+ */
+Xmpp_Auth * xmpp_auth_new_with_passwd (char * pwd);
+
+
+/**
  * Free the authentification structure
  * - free the password
  * - free the stream id

Modified: src/xmpp/xmpp_callback.c
===================================================================
--- src/xmpp/xmpp_callback.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/xmpp/xmpp_callback.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -40,7 +40,7 @@
   
   /* check if there is a authentification object */
   if (xm->auth == NULL) xm->auth = xmpp_auth_new ();
-
+  
   /* try to set the stream id */
   xm->auth->stream_id = egxp_message_get_attribute (msg, XMPP_ATT_ID);
   

Modified: src/xmpp/xmpp_opcode.c
===================================================================
--- src/xmpp/xmpp_opcode.c	2005-02-20 22:12:08 UTC (rev 20)
+++ src/xmpp/xmpp_opcode.c	2005-02-23 22:36:12 UTC (rev 21)
@@ -98,6 +98,5 @@
   egxp_node_add_condition (iq, egxp_condition_new (egxp_opcode_get_id (eg->opcodes, XMPP_ATT_ID),
 						   egxp_opcode_get_id (eg->opcodes, XMPP_VALUE_IQ_AUTH_1)));
   /* attach callback */
-  // egxp_node_set_cb (iq, NULL, xmpp_auth_auth_1_cb);
-  
+  egxp_node_set_cb (iq, NULL, xmpp_auth_auth_1_cb);
 }



From jol at sheep.berlios.de  Mon Feb 28 22:24:43 2005
From: jol at sheep.berlios.de (Joël Vennin at BerliOS)
Date: Mon, 28 Feb 2005 22:24:43 +0100
Subject: [Eim-svn] r22 - / src src/xmpp-im
Message-ID: <200502282124.j1SLOhtL005362@sheep.berlios.de>

Author: jol
Date: 2005-02-28 22:24:41 +0100 (Mon, 28 Feb 2005)
New Revision: 22

Added:
   src/xmpp-im/
   src/xmpp-im/Makefile.am
   src/xmpp-im/test.c
   src/xmpp-im/xmpp_im.h
   src/xmpp-im/xmpp_im_contact.c
   src/xmpp-im/xmpp_im_contact.h
   src/xmpp-im/xmpp_im_roster.c
   src/xmpp-im/xmpp_im_roster.h
   src/xmpp-im/xmpp_im_struct.h
Modified:
   ChangeLog
   configure.ac
   src/Makefile.am
Log:
- Just a first implementation of the Roster, Group and Contact
- Give an test example to check memory leak and the behavior of the new code
	


Modified: ChangeLog
===================================================================
--- ChangeLog	2005-02-23 22:36:12 UTC (rev 21)
+++ ChangeLog	2005-02-28 21:24:41 UTC (rev 22)
@@ -1,3 +1,7 @@
+2005-02-28(jol):
+	- Just a first implementation of the Roster, Group and Contact
+	- Give an test example to check memory leak and the behavior of the new code
+	
 2005-02-24(jol):
 	- Fix the bug ! The message was not correctly remove from the child list
 	of a message. The reason is that i didn't use correctly the ecore_list functions.

Modified: configure.ac
===================================================================
--- configure.ac	2005-02-23 22:36:12 UTC (rev 21)
+++ configure.ac	2005-02-28 21:24:41 UTC (rev 22)
@@ -76,5 +76,6 @@
 src/Makefile
 src/egxp/Makefile
 src/xmpp/Makefile
+src/xmpp-im/Makefile
 doc/Makefile
 ])

Modified: src/Makefile.am
===================================================================
--- src/Makefile.am	2005-02-23 22:36:12 UTC (rev 21)
+++ src/Makefile.am	2005-02-28 21:24:41 UTC (rev 22)
@@ -1,2 +1,6 @@
-SUBDIRS=egxp xmpp
+SUBDIRS= \
+	egxp    \
+	xmpp	\
+	xmpp-im
 
+

Added: src/xmpp-im/Makefile.am
===================================================================
--- src/xmpp-im/Makefile.am	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/Makefile.am	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,26 @@
+noinst_PROGRAMS = test
+
+test_SOURCES = \
+	test.c
+test_LDADD = \
+	-L$(top_srcdir)/src/egxp -legxp \
+	-L$(top_srcdir)/src/xmpp -lxmpp \
+	-lxmppim
+
+test_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) -I$(top_srcdir)/src
+
+
+noinst_LTLIBRARIES = libxmppim.la
+
+pkgincludeinputdir = $(pkgincludedir)/xmppim
+pkgincludeinput_HEADERS= \
+	xmpp_im_contact.h   \
+	xmpp_im_roster.h    \
+	xmpp_im_struct.h    \
+	xmpp_im.h
+
+libxmppim_la_SOURCES = \
+	xmpp_im_contact.c  \
+	xmpp_im_roster.c
+
+libxmppim_la_CFLAGS = $(ecore_cflags) $(IDN_CFLAGS) $(EXPAT_INCLUDE) -I$(top_srcdir)/src

Added: src/xmpp-im/test.c
===================================================================
--- src/xmpp-im/test.c	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/test.c	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,34 @@
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "xmpp/xmpp.h"
+#include "xmpp_im.h"
+
+
+int main (int argc, char ** argv) {
+
+  /**
+   * create a set of contact
+   * Add it to the group
+   */
+  XmppIM_Contact * contact;
+  Xmpp_JID * jid;
+  XmppIM_Roster * roster;
+
+  roster = xmpp_im_roster_new ();
+
+  char tmp[40];
+  int i;
+  for (i = 0; i < 300; i++) {
+    sprintf(tmp, "user%d", i);
+    jid = xmpp_jid_new (tmp, "host", "resource");
+    sprintf(tmp, "surname%d", i);
+    contact = xmpp_im_contact_new (jid, tmp);
+    xmpp_im_roster_add_contact (roster, contact);
+  }
+  
+  xmpp_im_roster_free (roster);
+
+  return 0;
+}

Added: src/xmpp-im/xmpp_im.h
===================================================================
--- src/xmpp-im/xmpp_im.h	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im.h	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,8 @@
+#ifndef xmpp_im_header
+#define xmpp_im_header
+
+#include "xmpp_im_struct.h"
+#include "xmpp_im_contact.h"
+#include "xmpp_im_roster.h"
+
+#endif

Added: src/xmpp-im/xmpp_im_contact.c
===================================================================
--- src/xmpp-im/xmpp_im_contact.c	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im_contact.c	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,70 @@
+#include <assert.h>
+#include <stdio.h>
+
+#include "xmpp_im_contact.h"
+
+XmppIM_Contact * xmpp_im_contact_new (Xmpp_JID * jid, char * name) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE:xmpp_im_contact_new\n");
+#endif
+  assert (jid);
+  
+  XmppIM_Contact * tmp = XMPPIM_CONTACT(malloc(sizeof (XmppIM_Contact)));
+  
+  tmp->jid = jid;
+  tmp->name = strdup (name);
+  tmp->groups = ecore_list_new ();
+  
+  return tmp;
+}
+
+
+void xmpp_im_contact_free (XmppIM_Contact * contact) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE:xmpp_im_contact_free\n");
+#endif
+  assert( contact != NULL);
+
+  /* unregister the contact from his group list */
+  xmpp_im_contact_remove_all_group (contact);
+  /* remove jid */
+  xmpp_jid_free (contact->jid);
+  /* free name */
+  IF_FREE (contact->name);
+  /* remove the list of attached groups */
+  ecore_list_destroy (contact->groups);
+  
+  FREE (contact);
+}
+
+
+void xmpp_im_contact_remove_all_group (XmppIM_Contact * c) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_contact_remove_all_group\n");
+#endif
+  assert (c != NULL);
+  
+  /* browse the group list */
+  ecore_list_goto_first(c->groups);
+  XmppIM_RosterGroup * group_item;
+  while((group_item = XMPPIM_ROSTERGROUP(ecore_list_next(c->groups))) != NULL) {
+    /* for each group remove this contact */
+    xmpp_im_roster_group_remove_contact (group_item, c);
+  }
+  
+  /* the list must be empty */
+  assert (ecore_list_is_empty (c->groups));
+}
+
+
+void xmpp_im_contact_display (void *contact, void * user_data) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_contact_display\n");
+#endif
+  
+  XmppIM_Contact * c = XMPPIM_CONTACT(contact);
+  
+  assert (c);
+  
+  printf("Surname %s\n", c->name);
+}

Added: src/xmpp-im/xmpp_im_contact.h
===================================================================
--- src/xmpp-im/xmpp_im_contact.h	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im_contact.h	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,39 @@
+#ifndef xmpp_im_contact_headers
+#define xmpp_im_contact_headers
+
+
+#include <Ecore_Data.h>
+
+#include "xmpp/xmpp_jid.h"
+#include "xmpp_im_struct.h"
+
+/**
+ * Create a new contact.
+ * @param jid: The jid of the user
+ * @param name: The name of the user
+ */
+XmppIM_Contact * xmpp_im_contact_new (Xmpp_JID * jid, char * name);
+
+
+/**
+ * Free the parameters.
+ */
+void xmpp_im_contact_free (XmppIM_Contact * contact);
+
+
+/**
+ * Remove all group of the contact. This function update the group
+ * contact list of each group.
+ * @param c: the contact
+ */
+void xmpp_im_contact_remove_all_group (XmppIM_Contact * c);
+
+
+
+/**
+ * Display information about contact in the stdout stream
+ * @param c: the contact to display
+ */
+void xmpp_im_contact_display (void *c, void * user_data);
+
+#endif

Added: src/xmpp-im/xmpp_im_roster.c
===================================================================
--- src/xmpp-im/xmpp_im_roster.c	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im_roster.c	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,222 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "xmpp_im_contact.h"
+#include "xmpp_im_roster.h"
+
+
+XmppIM_Roster * xmpp_im_roster_new () {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_new\n");
+#endif
+  
+  XmppIM_Roster * tmp = XMPPIM_ROSTER(malloc (sizeof (XmppIM_Roster)));
+
+  /* create and initialize the groups hash table */
+  tmp->groups = ecore_hash_new (ecore_str_hash, 
+				ecore_str_compare);
+  ecore_hash_set_free_value (tmp->groups,
+			     (Ecore_Free_Cb)xmpp_im_roster_group_free);
+  
+  
+  /* create and initialize the users hash table */
+  tmp->users = ecore_hash_new (ecore_str_hash, 
+			       ecore_str_compare);
+  ecore_hash_set_free_value (tmp->users, 
+			     (Ecore_Free_Cb)xmpp_im_contact_free);
+  
+  return tmp;
+}
+
+
+void xmpp_im_roster_update_from_message (XmppIM_Roster *r,
+					 Egxp_Message *m) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_update_from_message\n");
+#endif
+  }
+
+
+
+void xmpp_im_roster_free (XmppIM_Roster * r) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_free\n");
+#endif
+  ecore_hash_destroy (r->users);
+  ecore_hash_destroy (r->groups);
+  FREE (r);
+}
+
+
+void xmpp_im_roster_add_group (XmppIM_Roster * r, XmppIM_RosterGroup * g) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_add_group\n");
+#endif
+  
+  assert (r != NULL && g != NULL);
+  
+  /* add the group, the key is the groupname */
+  ecore_hash_set(r->groups, g->groupname, g);
+}
+
+
+void xmpp_im_roster_add_contact (XmppIM_Roster * r, XmppIM_Contact * c) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_add_contact\n");
+#endif
+
+  assert (r != NULL && r->users != NULL && c != NULL);
+  
+  ecore_hash_set (r->users, c->name, c);
+}
+
+
+void xmpp_im_roster_remove_contact (XmppIM_Roster * r, XmppIM_Contact * c) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_roster_remove_contact\n");
+#endif
+
+  assert (r != NULL && c != NULL);
+
+  /* remove the contact from his groups */
+  xmpp_im_contact_remove_all_group (c);
+  
+  /* remove the contact from the user hash */
+  XmppIM_Contact * tmp = XMPPIM_CONTACT (ecore_hash_remove (r->users, c->name));
+  
+  assert (tmp == c);
+}
+
+
+
+XmppIM_Contact * xmpp_im_roster_get_contact (XmppIM_Roster *r, char * jid) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_get_contact\n");
+#endif
+
+
+  assert (r != NULL && jid != NULL);
+  assert (r->users != NULL);
+  
+  XmppIM_Contact * tmp = XMPPIM_CONTACT (ecore_hash_get (r->users, jid));
+  return tmp;
+}
+
+
+
+XmppIM_RosterGroup * xmpp_im_roster_add_contact_to_group (XmppIM_Roster *r, XmppIM_Contact * c, char *groupname) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_add_contact_to_group\n");
+#endif
+
+  assert (r != NULL && c != NULL && groupname != NULL);
+  assert (r->groups != NULL);
+
+  /* get a reference to a group */
+  XmppIM_RosterGroup * group = XMPPIM_ROSTERGROUP (ecore_hash_get (r->groups, groupname));
+  
+  /* if the group doesn't exist we create it */
+  if (group == NULL) {
+    group = xmpp_im_roster_group_new (groupname);
+    xmpp_im_roster_add_group (r, group);    
+  }
+  
+  /* now we can add the contact to the group */
+  xmpp_im_roster_group_add_contact (group, c);
+  
+  return group;
+}
+
+
+
+XmppIM_RosterGroup * xmpp_im_roster_group_new (char * groupname) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_group_new\n");
+#endif
+  
+  XmppIM_RosterGroup * tmp = XMPPIM_ROSTERGROUP(malloc (sizeof (XmppIM_RosterGroup)));
+  assert(tmp != NULL);
+  printf("XmppIM_RosterGroup: %X %d\n", tmp, sizeof (XmppIM_RosterGroup));
+  /* allocate memory for the groupname  and the users list */
+  tmp->groupname = strdup (groupname);
+  tmp->users = ecore_list_new ();
+  
+  return tmp;
+}
+
+
+void xmpp_im_roster_group_free (XmppIM_RosterGroup * r) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_group_free\n");
+#endif
+
+  /* free the group name */
+  IF_FREE(r->groupname);
+
+  /* destroy the list, we don't free the contact because their owner is the roster */
+  ecore_list_destroy (r->users);
+  FREE (r);
+}
+
+
+void xmpp_im_roster_group_remove_contact (XmppIM_RosterGroup * rg, XmppIM_Contact * ec) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_group_remove_contact\n");
+#endif
+
+  assert (rg != NULL && ec != NULL);
+
+  /* go to the beginning of the users list */
+  ecore_list_goto_first(rg->users);
+  XmppIM_Contact * contact_item;
+  
+  while((contact_item = XMPPIM_CONTACT(ecore_list_current(rg->users))) != NULL) {
+    /* If we find the contact, we remove it from the list */
+    if( contact_item == ec) {
+      ecore_list_remove (rg->users);
+      return;
+    }
+    /* advance inside the list */
+    ecore_list_next (rg->users);
+  }
+}
+
+void xmpp_im_roster_group_add_contact (XmppIM_RosterGroup * rg, XmppIM_Contact *ec) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_group_add_contact\n");
+#endif
+  
+  assert (rg != NULL && ec != NULL && ec->groups != NULL);
+
+  /* update the contact list group of the user*/
+  ecore_list_append (ec->groups, rg);
+  
+  /* update the user group list of the group */
+  ecore_list_append (rg->users, ec);
+}
+
+
+void xmpp_im_roster_group_display (void * node, void * user_data) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_group_display\n");
+#endif
+
+  XmppIM_RosterGroup * g = XMPPIM_ROSTERGROUP(ECORE_HASH_NODE(node)->value);
+  
+  assert (g != NULL);
+  assert (g->users != NULL);
+
+
+  ecore_list_for_each (g->users, ECORE_FOR_EACH(xmpp_im_contact_display), NULL);
+}
+
+void xmpp_im_roster_display (XmppIM_Roster *r) {
+#ifdef XMPPIM_DEBUG
+  printf("TRACE: xmpp_im_roster_display\n");
+#endif
+  
+  assert (r != NULL);
+  
+  printf("--- Roster Information ---\n");
+  ecore_hash_for_each_node (r->groups, ECORE_FOR_EACH(xmpp_im_roster_group_display), NULL);
+}

Added: src/xmpp-im/xmpp_im_roster.h
===================================================================
--- src/xmpp-im/xmpp_im_roster.h	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im_roster.h	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,120 @@
+#ifndef header_xmpp_im_roster_h_
+#define header_xmpp_im_roster_h_
+
+#include "egxp/egxp_message.h"
+#include "xmpp_im_struct.h"
+
+/**
+ * Create a new roster object
+ * - initialize the group hash map
+ * - initialize the users hash map
+ * @return: the newly created roster
+ */
+XmppIM_Roster * xmpp_im_roster_new ();
+
+
+/**
+ * Delete a roster
+ * - free all memory used by the roster
+ * - remove all groups and all users
+ * @param r: the roster to be freed
+ */
+void xmpp_im_roster_free (XmppIM_Roster * r);
+
+
+/**
+ * Add a group to the roster
+ * @param r: the roster
+ * @param g: the group to add
+ */
+void xmpp_im_roster_add_group (XmppIM_Roster * r, XmppIM_RosterGroup * g);
+
+/**
+ * Add a contact to the roster.
+ * - add the contact inside the user hashmap
+ * - this function do nothing about group of the contact.
+ */
+void xmpp_im_roster_add_contact (XmppIM_Roster * r, XmppIM_Contact * c);
+
+
+/**
+ * Remove a contact from the roster,
+ * - remove all attached group of the xmpp_im_contact.
+ * @param r: the roster
+ * @param c: the contact to remove.
+ * @warning: the contact are not freed.
+ */
+void xmpp_im_roster_remove_contact (XmppIM_Roster * r, XmppIM_Contact * c);
+
+
+/**
+ * Return the contact structure in function of the jid bare
+ * @param r: the roster
+ * @param jid: the bare jid of the searched user 
+ */
+XmppIM_Contact * xmpp_im_roster_get_contact (XmppIM_Roster *r, char * jid);
+
+
+/**
+ * Add a contact to a group:
+ *  - update the group list of the contact
+ *  - if the group doesn't exist in the roster, create it and add the XmppIM_Contact inside
+ * @param r: The roster,
+ * @param c: contact to add to the group,
+ * @param groupname: the name of the group.
+ * @return: return the group on which we have added 
+ */
+XmppIM_RosterGroup * xmpp_im_roster_add_contact_to_group (XmppIM_Roster *r, XmppIM_Contact * c, char *groupname);
+
+
+/**
+ * This method display the roster in the stdout stream.
+ * @param r: The concern roster.
+ */
+void xmpp_im_roster_display (XmppIM_Roster *r);
+
+
+/**
+ * Create a group
+ */
+XmppIM_RosterGroup * xmpp_im_roster_group_new (char * groupname);
+
+
+
+/**
+ * Delete a group
+ */
+void xmpp_im_roster_group_free (XmppIM_RosterGroup * );
+
+
+/**
+ * Remove the contact from the roster group. This function doesn't remove
+ * the reference of the user to this group.
+ */
+void xmpp_im_roster_group_remove_contact (XmppIM_RosterGroup * rg, XmppIM_Contact * ec);
+
+
+/**
+ * Add a contact to a group
+ * - update the contact group list
+ * - update the group
+ */
+void xmpp_im_roster_group_add_contact (XmppIM_RosterGroup * rg, XmppIM_Contact *ec);
+
+
+/**
+ * This function update the roster from a message. The message must be a 
+ * iq message. Next we get all contact from this message and update 
+ * their status.
+ * @param r: the concern roster
+ * @param m: the message that contains all information.
+ */
+void xmpp_im_roster_update_from_message (XmppIM_Roster *r, Egxp_Message *m);
+
+
+/**
+ * This method display the group roster information in the stdout stream.
+ * @param r: The concern roster group.
+ */
+void xmpp_im_roster_group_display (void * i, void * user_data);
+#endif

Added: src/xmpp-im/xmpp_im_struct.h
===================================================================
--- src/xmpp-im/xmpp_im_struct.h	2005-02-23 22:36:12 UTC (rev 21)
+++ src/xmpp-im/xmpp_im_struct.h	2005-02-28 21:24:41 UTC (rev 22)
@@ -0,0 +1,57 @@
+#ifndef header_xmpp_im_struct_header
+#define header_xmpp_im_struct_header
+
+#include <Ecore_Data.h>
+
+#include "xmpp/xmpp_jid.h"
+
+typedef struct _XmppIM_Contact XmppIM_Contact;
+#define XMPPIM_CONTACT(o) ((XmppIM_Contact*)o)
+struct _XmppIM_Contact {
+  
+  /* the jid of the contact */
+  Xmpp_JID * jid;
+  
+  /* the name of the contact */
+  char * name;
+
+  /* List of group reference */
+  Ecore_List * groups;
+};
+
+
+/**
+ *  This is the definition of the roster. The roster is composed of 
+ *  different group. By default we created a group called __default__group__.
+ *  So each user who has no group must be inside this one.
+ */
+typedef struct _XmppIM_Roster  XmppIM_Roster;
+#define XMPPIM_ROSTER(o) ((XmppIM_Roster*)o)
+struct _XmppIM_Roster {
+  
+  /* a hash structure to store group, key is group name, the value
+     is a reference on the XmppIM_Contact
+  */
+  Ecore_Hash * groups;
+  
+  /** 
+   * Keep a hash on the XmppIM_Contact, the key is the bare id 
+   */
+  Ecore_Hash * users;  
+};
+
+
+
+typedef struct _XmppIM_RosterGroup XmppIM_RosterGroup;
+#define XMPPIM_ROSTERGROUP(o) ((XmppIM_RosterGroup*)o)
+struct _XmppIM_RosterGroup {
+  
+  /* group name*/
+  char * groupname;
+  
+  /* contains a list of XmppIM_Contact element*/
+  Ecore_List * users;
+};
+
+
+#endif



